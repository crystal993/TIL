### 🐬 ==와 ===의 차이점

#### 1. 느슨한 비교 ==

```javascript
1 == '1'; // true
0 == '0'; // true
0 == []; // true => 이상함
```

- 간단하게 말하면 값만 비교

- 동등 비교(==) 연산자는 좌항과 우항을 비교할 때, 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교한다.

- 따라서 타입이 다르더라도 암묵적 타입 변환 후에 같은 값이라면 true를 반환한다.

<br>

#### 2. 엄격한 비교 ===

```javascript
1 === 1; // true
1 === '1'; // false
0 === []; // false
```

- 간단하게 말하면 `값`과 `타입`이 같은 경우에만 true를 반환

- 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입이 같고, 값이 같은 경우에 한하여 true를 반환한다.

- ⇒ 동등 비교(==)는 예측하기 어려운 결과를 만들어내므로, 일치 비교(===) 연산자를 사용하는 것이 권장된다.

<br><br>

### 🐬 참조타입의 비교 - 객체와 배열의 비교

<br>

```javascript
let arr = [1, 2, 3];
console.log(arr === [1, 2, 3]); //false
```

<br>

- `arr === [1,2,3]`은 `false`가 나온다.
- 위의 느슨한 비교, 엄격한 비교와는 다른 결과값이 나오는 것 같다.
- 원시타입, 참조타입이 메모리에 값을 저장하는 방식이 달라서 생긴 결과이다.

- ⭐⭐⭐ arr와 [1,2,3]의 `주소값`과 `타입`을 비교
- === 연산자의 좌항 arr의 [1,2,3]은 주소값 101을 가진다면
- === 연산자의 우항 [1,2,3]은 새로운 배열이 생성되므로 새로운 주소값 103을 가진다고 보면 된다.

<br><br>

### 원시타입 불변성, 참조타입 가변성 참고

#### 1) 원시 타입

1. String
2. Number
3. Boolean
4. Bigint
5. undefined
6. Symbol
7. Null

<br><br>

##### 1. 원시타입은 불변성을 갖는다.

- 데이터가 변화하지 않는 특징을 가진다.

```javascript
let str = 'abc';
str = 'def'; // 값을 재할당
```

- 값을 재할당했으니 변수의 데이터가 변화한 거라 생각하기 쉬움.

<br><br>

str => 101 (x) 102 (o)

<br>

101 => "abc"
102 => "def"

<br><br>

- `str` 변수가 메모리에 `'abc'`를 담고 있는 게 아니라 `'abc'` 문자열이 저장된 주소값 101을 갖고 있다.

* `'abc'` 문자열은 다른 임시 메모리에 저장이 된다.
* 101 이라는 숫자는 임의로 정한 것임 \*

- `'def'`라는 문자열을 `str`변수에 재할당할 때
  `'def'`문자열이 저장된 주소값 102를 가지게 된다.

- ⭐ `str` 변수에 값을 재할당을 해도 따라서 `'abc'` 문자열이 저장된 주소값 101과 `'def'`문자열이 저장된 주소값 102는 변하지 않는다.

- ⭐ 원본 데이터 `'abc'`에는 아무런 영향을 주지 않는다.

- ⭐ 원시타입 String은 불변성을 갖는다.

<br><br>

#### 2) 참조 타입

```javascript
let obj = {
  name: 'otter',
  age: 25,
};
```

<br><br>

obj => 201

<br>

201 => 414 => { name: 'otter', age: 25}

<br><br>
