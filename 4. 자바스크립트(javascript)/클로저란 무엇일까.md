# 클로저 (Closure)

클로저는 일반적으로 어떤 함수가 자신의 내부가 아닌
외부에서 선언된 변수에 접근하는 것을 뜻한다.

- 클로저는 내부함수의 변수가 외부함수의 변수에 접근할 수 있는 것을 의미합니다.

- 즉 클로저 함수 안에서는 지역변수, 외부함수의 변수, 전역변수 모두 다 접근이 가능합니다.

- 클로저는 변경이 되지 않아야 하지만 해당 값을 읽고 싶을 때 주로 사용되어집니다.

- 클로저는 정보를 은닉 즉, 캡슐화가 필요할 때 사용되어집니다. 클로저 함수를 통해서 중요한 데이터가 외부로부터 오염되는 것을 막을 수 있습니다. 뿐만 아니라 템플릿처럼 하나의 함수를 재사용 하고 싶을 때도 사용되어집니다.

- 외부함수에 접근할 수 있는 내부함수 혹은 이러한 원리를 일컫는 용어인데

- 스코프에 따라서 내부함수의 범위에서는 외부 함수 범위에 있는 변수에 접근이 가능하지만, 그 반대는 실현이 불가능하다는 개념입니다.

- 반복문과 비동기 함수가 만날 때 문제가 자주 발생하는데, 클로저의 특성을 사용해서 해결할 수 있습니다.

## 클로저 정리

- 클로저의 핵심은 스코프를 이용해서 변수의 접근 범위를 닫는 것에 있다.

  - 외부 함수 스코프에서 내부 함수 스코프로 접근이 불가능하다.

  -내부 함수에서는 외부 함수 스코프에 선언된 변수에 접근이 가능하다.

  -내부 함수는 외부 함수에 선언된 변수에 접근이 가능하다.

- 함수가 호출되는 환경과 별개로 기존에 선언되어 있던 환경을 기준으로 변수를 조회한다.

  - 외부함수의 실행이 종료된 후에도 클로저 함수는 외부함수의 스코프, 즉 함수가 선언된 어휘적 환경에 접근할 수 있다.

  - 외부함수 스코프가 내부함수에 의해 언제든지 참조될 수 있다.

  - 따라서 클로저를 남발할 경우 퍼포먼스 저하가 발생할 수도 있다.

<br><br>

## 클로저 함수의 장점

#### 1. 데이터를 보존할 수 있다.

클로저 함수는 외부 함수의 실행이 끝나더라도 외부함수 내 변수를 사용할 수 있다. 클로저는 이처럼 특정 데이터를 스코프 안에 가두어 둔 채로 계속 사용할 수 있게 하는 폐쇄성을 갖는다.

#### 2. 정보의 접근 제한 (캡슐화)

'클로저 모듈 패턴'을 사용해 객체에 담아 여러개의 함수를 리턴하도록 만든다.

이러한 정보의 접근을 제한하는 것을 캡슐화라고 한다.

#### 3. 모듈화에 유리하다.

클로저 함수를 각각의 변수에 할당하면 각자 독립적으로 값을 사용하고 보존할 수 있다.

이와 같이 함수의 재사용성을 극대화한 함수 하나를 독립적인 부품의 형태로 분리하는 것을 모듈화라고 한다.

클로저를 통해 데이터와 메소드를 묶어 다닐 수 있기에 클로저는 모듈화에 유리하다.

## 예

다음과 같이 미국 달러를 대한민국의 원으로 환전해주는 간단한 함수를 예를 들어 살펴보자.
이 함수는 미국 달러를 인자로 받아 함수 내부에 선언된
환율을 이용하여 대한민국 원으로 환전한 결과를 반환한다.

```javascript
function convertUsToKrw(dollar) {
  const rate = 1113.5;
  return dollar * rate;
}
```

인자로 5달러를 넘겨서 이 함수를 호출하면 예상대로 5567.5원이 반환된다.

```javascript
 > convertUsToKrw(5)
5567.5
```

이번엔 환율(rate)을 함수 외부에 선언하면?

```javascript
const rate = 1113.5;

function convertUsToKrw(dollar) {
  return dollar * rate;
}
```

이 함수를 동일한 인자를 넘겨 호출해보면 완전히 동일한 결과값이 반횐되는 것을 알 수 있다.

```javascript
 > convertUsToKrw(5)
5567.5
```

이렇게 JS에서 함수는 매개변수와 로컬변수 뿐만아니라 외부에서 선언된 변수도 자유롭게 접근을 할 수 있다.

=> ⭐⭐이렇게 함수가 자신의 밖에서 선언된 변수에 접근하는 것을 클로저라고 한다.

# 클로저의 다른 예

js를 사용하면서 개발자들은 알게 모르게 이미 작성하는 코드의 많은 부분에서 클로저를 사용하고 있다.

특히 어떤 함수 내에서 또 다른 함수를 선언할 때 알게 모르게 클로저를 자주 사용하게 된다.

```javascript
function batchConvertUsdToKrw(dollars) {
  const rate = 1113.5;
  const convertUsdToKrw = (dollar) => dollar * rate;
  return dollars.map(convertUsdToKrw);
}
```

```javascript
> batchConvertUsdToKrw([1, 2, 10, 20, 50, 100])
[ 1113.5, 2227, 11135, 22270, 55675, 111350 ]
```

js 배열의 map() 메서드의 인자로 convertUsToKrw()함수가 넘어가고 있다. 여기서 batchConvertUsToKrw() 함수의 내부에서 선언된 rate 변수는 convertUsdToKrw() 함수의 입장에서 보면 외부에서 선언이 되어 있다.

즉 convertUsdToKrw() 함수는 자신의 내부가 아닌 외부에서 선언된 rate 변수에 접근하고 있으므로 정확히 위에서 정의한 클로저라는 것을 알 수 있다.

<br><br>

https://velog.io/@ahsy92/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%ED%81%B4%EB%A1%9C%EC%A0%80Closures%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C
