## React

### 🐬 리액트란?

리액트는 UI 자바스크립트 라이브러리로서 싱글 페이지 어플리케이션의 UI를 생성하는 데 집중한 라이브러리입니다. 리액트는 자바스크립트에 HTML을 포함하는 JSX 문법과 단방향 데이터 바인딩을 사용하고 있습니다. 그리고 가상돔이라는 개념을 사용하여 웹 애플리케이션의 성능을 향상시키고, 클라이언트 사이드 렌더링이 가능합니다.

- 개념: UI를 구축하기 위한 자바스크립트 프론트엔드 라이브러리

  사용자와 웹사이트의 상호작용을 돕는 사용자 인터페이스(UI)를 만들기 위한 자바스크립트 라이브러리

- 장점:

  - virtual DOM을 사용해서 어플리케이션의 성능을 향상시킴

  - 서버, 클라이언트 사이드 렌더링 지원이 가능함

  - 컴포넌트의 가독성이 높고 간단하여 유지보수가 쉬움

  - 다른 프레임워크와도 혼용이 가능

<br>
<br>

### 🐬 컴포넌트란?

프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈. 레고블럭과 같이 작은 단위로 만들어서 그것을 조립하는 것처럼 화면을 구성하는 방법입니다. 컴포넌트를 사용한다면 캡슐화, 확장성, 결합성, 재사용성과 같은 이점이 있습니다.

- 캡슐화 : 정보은닉, 객체에 대한 구체적인 정보를 노출시키지 않도록 하기 위해서

<br>
<br>

### 🐬 Props란?

props는 부모컴포넌트에서 자식컴포넌트로 전달해주는 객체입니다

- props는 읽기 전용이다.
  - 모든 리액트 컴포넌트는 자신의 props를 다룰 때 반드시 순수함수처럼 동작해야 한다.
- 컴포넌트에 어떤 데이터를 전달하고, 전달된 데이터에 따라 다른 모습의 엘리먼트를 화면에 렌더링 하고 싶을 때 해당 데이터를 props에 넣어서 전달하는 것이다.

<br>
<br>

### 🐬 Props와 state의 차이?

![image-20221129172329353](C:\Users\ggg71\AppData\Roaming\Typora\typora-user-images\image-20221129172329353.png)

- props와 state 둘다 js 객체
- props와 state 모두 변경시에 렌더링이 발생
- 구성요소가 동일한 props 및 state 조합에 대해 다른 출력을 하는 경우 잘못된 작업을 수행하고 있는 것이다.

<br>
<br>

### 🐬 리액트 엘리먼트 VS 돔 엘리먼트

- 엘리먼트 : 어떤 물체를 구성하는 성분

- 돔 엘리먼트 : 실제 돔에 존재하는 엘리먼트
- 리액트 엘리먼트 : 가상 돔에 존재하는 리액트 앱을 구성하는 가장 작은 블록들
  - 포넌트 유형과 속성 및 모든 자식에 대한 정보를 포함하고 있는 자바스크립트 객체 형태로 존재

<br>
<br>

### 🐬 React, 왜 사용하시나요?

- SPA
- React native 앱 개발이 가능
- 수많은 커뮤니티가 존재
- 컴포넌트 재사용 가능 (유지보수 용이)

<br>
<br>

### 🐬 리액트의 특징

#### 1. 가상돔 (웹 애플리케이션의 성능을 극대화 )

- 리액트는 리플로우와 리페인트가 자주 수행되는 문제를 해결하기 위해 화면에 표시되는 DOM과 동일한 DOM을 메모리상에 만들고 DOM 조작이 발생하면 메모리상에 생성한 가상 돔에 모든 연산을 수행한 후, 실제 DOM을 갱신하여 리플로우/리페인트의 연산을 최소화했습니다.

#### 2. 단방향 데이터 바인딩

- 단방향 데이터 바인딩은 단 하나의 watcher가 자바스크립트의 데이터 갱신을 감지하여 사용자의 UI 데이터를 갱신합니다. 사용자가 UI를 통해 자바스크립트의 데이터를 갱신할 때는, 이벤트를 통해 갱신하게 됩니다. 이처럼 단방향 데이터 바인딩은 하나의 Watcher를 사용하기 때문에 양방향 데이터 바인딩이 가지는 성능적인 이슈를 해결하고 더 확실하게 데이터를 추적할 수 있게 해줍니다. (양방향 데이터 바인딩은 하나의 데이터 동기화에 두 개의 Watcher가 사용되고, 데이터가 많아지게 되면 이 데이터의 동기화를 위한 수많은 Watcher가 생성되므로 반대로 성능 저하가 발생할 수 있다. )

#### 3. JSX

- JSX는 자바스크립트와 HTML을 동시에 사용하며, HTML에 자바스크립트의 변수들을 바로 사용할 수 있는 일종의 템플릿 언어 (Template language)입니다.

#### 4. 선언형 프로그래밍

- 프로그래밍에는 명령형 프로그래밍과 선언형 프로그래밍으로 구별할 수 있습니다. 명령형 프로그래밍은 프로그래밍을 할 때 어떻게(How)에 집중하는 것을 말하며 선언형 프로그래밍은 무엇(What)에 집중하여 프로그래밍을 하는 것을 말합니다.

#### 5. 컴포넌트 기반

- 컴포넌트는 재사용을 할 수 있으며 이런 재사용을 통해 개발 생산성을 향상시킬 수 있습니다. 또한 이렇게 작고 고립된 컴포넌트는 테스트 하기 쉬워 코드를 유지보수하는 데도 크게 도움이 됩니다.

<br>
<br>

### 🐬 리액트의 내부 작동 원리를 재조정(Reconciliation) 개념과 함께 설명하세요.

React에서 DOM을 어떻게 렌더링하고 브라우저 이벤트를 처리하나요?
실제로 DOM을 제어하지 않고, 중간에 virtual DOM을 두어 virtual DOM이 변경될 때, 실제 DOM을 변경하도록 설계되어 있습니다. 이 작업을 Reconciliation이라고 합니다. virtual DOM을 갱신하는 방법에는 setState()메소드를 호출하는 방법과 redux의 경우처럼 store가 변하면 다시 최상위 컴포넌트의 render()함수를 호출해서 갱신하는 2가지 방법이 있습니다.

<br>
<br>

### 🐬 리액트에 있는 라이프사이클과 각 라이프사이클의 역할을 설명하세요.

리액트의 라이프사이클은 크게 4가지로 설명할 수 있습니다. 최초로 컴포넌트 객체가 생성될 때 한 번 수행되어지는 componentDidMount()와 초기에 화면을 그려줄 때와, 업데이트가 될 때 호출되는 render()가 있습니다. 그리고 컴포넌트의 속성 값 또는 상태값이 변경되면 호출되어지는 componentDidUpdate()와 마지막으로 컴포넌트가 소멸될 때 호출되어지는 componentWillUnmount()가 라이프사이클의 역할입니다.

<br>
<br>

### 🐬 리액트 Hooks의 장점은 무엇인가요?

Hooks의 장점은 로직의 재사용이 가능하고 관리가 쉽다는 것입니다. 함수안에서 다른 함수를 호출하는 것으로 새로운 hook을 만들어볼 수 있습니다. 기존의 class component는 여러단계의 상속으로 인해 전반적으로 복잡성과 오류 가능성을 증가시켰습니다. 하지만 function component에 hooks에 도입되면서 class component가 가지고 있는 기능을 모두 사용할 수 있음은 물론이고 기존 class component 복잡성, 재사용성의 단점들까지 해결됩니다.

<br>
<br>

### 🐬 Class Component와 Function Component의 차이점에 대해서 설명하세요.

Class Component는 여러 단계의 상속으로 이루어져 있습니다. 그리하여 복잡성과 오류 가능성을 증가 시켰습니다. 이로 인해 Function Component가 탄생하게 되었고, class component는 라이프 사이클을 가지며 이로인해 각각 생명주기 메소드에 대해 알고 있어야 합니다. 하지만 function component는 이러한 기능을 hook을 사용하여 생명주기에 원하는 동작을 하게 합니다.

<br>
<br>

### 🐬 React의 리렌더링 조건은?

4가지가 있습니다.

- 상태(state)값이 변경될 때
- 부모 컴포넌트가 리렌더링될 때
- 자신이 전달받은 props값이 변경될 때
- 강제 업데이트(forceUpdate)함수

<br>
<br>

### 🐬 React 에서 상태 변화가 생겼을 때, 변화를 어떻게 알아채는지에 대해서 설명하세요.

React는 상태를 불변성을 띄게 변경합니다. 그로 인해 배열이나 객체의 주소값이 변경되면 변화가 되었다는 것을 알 수 있습니다.

- 리액트는 상태값을 업데이트할 때 얕은 비교를 수행한다.
- 객체의 속성 하나하나를 비교하는 게 아니라 참조값만 비교하여 상태변화를 감지한다.
- 값이 아무리 변화하더라도 참조값은 그대로이므로 ...(스프레드 연산자)를 사용해서 새로운 참조값을 만들어서 사용한다.
- 이러한 이유로 배열이나 객체를 업데이트할 때 ...(스프레드 연산자)를 사용해서 배열이나 객체를 새로 생성해서 새로운 참조값을 만들어서 상태를 업데이트 한다. => 불변성을 지켜준다.

<br>
<br>

### 🐬 React 에서의 불변성

#### 💡 정리

- **불변성**이란 **메모리 영역의 값을 변경할 수 없는 것**이다.
- 리액트는 **불변성**을 지켜줌으로써 **효율적인 상태 업데이트**를 한다.
- 리액트는 불변성을 지켜줌으로써 사이드 이펙트를 사전 방지하고 프로그래밍의 구조를 단순하게 유지한다.
- 불변성을 가진 원시타입과 달리 참조타입의 경우에는 의도적으로 불변성을 지켜주어야한다. 이 때 새로운 주소 값을 가진 객체를 생성하여 상태를 업데이트 해준다. spread operator, map, filter, slice, reduce 메소드들을 활용한다.

<br>

#### 💡 불변성이란?

- 불변성은 값의 변화를 의미하는 것이 아니다.

- 불변성의 진짜 의미는 **메모리 영역에서 값을 변경할 수 없다는 의미**이다.

<br>

#### 💡 React에서 불변성을 왜 지켜야할까?

리액트에서 불변성을 지켜주는 이유는 리액트가 상태 업데이트를 하는 원리 때문입니다.

React는 상태를 불변성을 띄게 변경합니다. 그로 인해 상태 객체의 주소값이 변경되면 변화가 되었다는 것을 알 수 있습니다.

- 효율적인 상태 업데이트 (얕은 비교 수행)

  => 상태업데이트 원리는 위의 질문에 대한 답에 있음.

  : 얕은 비교란 객체의 속성을 하나하나 다 비교하지 않고, 객체의 참조 주소값만 변경되었는지 확인합니다. 얕은 비교는 계산 리소스를 줄여주기 때문에 리액트는 효율적으로 상태를 업데이트 할 수 있습니다.

- 사이드 이펙트 방지 및 프로그래밍 구조의 단순성

  : 원시타입은 애시당초 불변성 특징을 가지고 있지만, 참조 타입인 객체나 배열의 경우 새로운 값을 변경할 때 원본 데이터가 변경됩니다. (불변성이 지켜지지 않습니다.) 이렇게 원본 데이터가 변경될 경우, 이 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류가 발생할 수 있습니다. 프로그램 복잡도가 올라갑니다.

<br>

#### 💡 React에서 불변성을 지키는 방법

- spread operator, map, filter, slice, reduce, concat 등등 새로운 배열을 반환하는 메소드들을 활용하면 된다.
- 참조타입의 경우에는 새로운 주소값을 가진 객체를 생성하여 상태를 업데이트 해준다.

<br>
<br>

### 🐬 상태 관리를 왜 할까요? 그리고 평소에 state 관리는 어떻게 하시나요?

상태관리란 웹 어플리케이션을 render하는데 있어 영향을 미칠 수 있는 값을 관리하는 것을 의미합니다.

상태관리를 하는 이유는 2가지가 있습니다.

첫번째는 상태관리는 UI에 직/간접적으로 영향을 주게 됩니다. 따라서 상태를 제대로 관리하지 못하면 유저에게 어색한 경험을 제공하거나 버그가 생기게 됩니다.

두번째는 리액트는 단방향 데이터 바인딩을 하므로 부모에서 자식 컴포넌트로만 데이터 전달이 가능합니다. props drilling이 심할 때나 여러 컴포넌트에서 접근해서 사용하는 상태 값을 가질 경우에 유지보수가 어려워지고, 이를 해결하기 위해 상태관리가 필요합니다.

평소에 모달창을 열고 닫는 상태값처럼 한 컴포넌트 내에서 상태값 관리가 가능하면 useState로 상태관리를 하고, 단순 props drilling이 심할 때나 적당히 복잡한 컴포넌트가 존재하고, 외부 라이브러리를 쓰고 싶지 않을 때는 context와 useReducer 조합을 사용합니다. 특정 구성 요소만 re-render 시키거나, 사이드 이펙트를 줄이기 위해서 redux toolkit을 사용하여 관리합니다.

<br>

- 상태란? 웹 어플리케이션을 render하는데 있어 영향을 미칠 수 있는 값이다.

- 상태관리란? 웹 어플리케이션을 render하는데 있어 영향을 미칠 수 있는 값을 관리하는 것을 의미

- 상태의 종류? 전역 상태, 컴포넌트 간의 상태, 지역 상태

- 상태관리는 왜 필요할까?

  1. UI에 직/간접적으로 영향을 주기 때문에 => 유저에게 어색한 경험, 버그 발생

  2. 리액트는 단방향 데이터 바인딩을 하므로 부모에서 자식컴포넌트로만 데이터 전달이 가능하다. props drilling이 심할 때나 여러 컴포넌트에서 접근해서 사용하는 상태값을 가질 경우에 유지보수가 어려워진다. 이를 해결하기 위해 상태관리가 필요하다.

<br>

- 나의 상태관리

  1. useState

     : 모달창을 열고 닫는 상태값처럼 한 컴포넌트 내에서 상태값 관리가 가능할 때 사용

  2. context와 useReducer 조합

     : 단순 props drilling이 심할 때나 적당히 복잡한 컴포넌트가 존재할 때, 낮은 빈도의 업데이트와 같은 정적인 상태의 전달, 외부 라이브러리를 쓰고 싶지 않을 때 사용

  3. redux-toolkit

     : 2번보다 강력한 기능이 필요할 때! props drilling도 심하고 굉장히 복잡한 컴포넌트 구조이거나 저장소 상태의 특정 부분만 사용하고, 해당 값을 re-render 시키거나, 사이드 이펙트를 줄이기 위해서 사용.

<br>

(useReducer는 context내부에 포함된 컴포넌트들이 상태값의 일부에만 관심있더라도 강제로 re-render되므로 성능문제 발생. useReducer는 미들웨어도 존재하지 않는다. )

<br>
<br>

#### 💡 1-1. props drilling이란?

리액트는 대표적으로 단방향 데이터흐름 이라는 특징이 있습니다. 이는 data를 전달 할 때 부모 컴포넌트에서 자식 컴포넌트로만 데이터 전달이 가능합니다. 예를 들어 부모컴포넌트에서 props를 통해 최하위 자식컴포넌트로 데이터를 전달해야할 때, 중간 컴포넌트는 그 데이터가 필요하지 않음에도 불구하고 props를 전달하는 과정을 props drilling이라고 합니다.

- Props drilling으로 발생하는 문제점

  - 여러개의 컴포넌트를 타고 내려가다 보면 props의 지옥이 펼쳐지고 이 props가 도대체 어디서부터 시작된건지 타고 올라가는 것이 쉽지 않습니다. 이 때문에 유지 보수 또한 어려워진다.

  - ⭐ props를 통해 여러번 전달되는 데이터가 전달되는 경우 실제 변화가 적용되어야 하는 컴포넌트 뿐만 아니라 전달 경로에 있는 컴포넌트들도 리렌더하는 문제가 발생합니다.

<br>
<br>

#### 💡 1-2. Context API와 Redux의 차이

- context + useReducer는 context를 통해 현재 상태값을 전달하는데 의존한다. Redux는 Context를 통해 현재 Redux 스토어 인스턴스를 전달한다.
- useReducer는 context내부에 포함된 컴포넌트들이 상태값의 일부에만 관심있더라도 강제로 re-render되므로 성능문제 발생. useReducer는 미들웨어도 존재하지 않는다.
- Redux를 사용하면 저장소 상태의 특정 부분만 사용하고 해당 값이 변경될 때만 re-render 한다.

- Context, useReducer는 React에 내장되어 있는 기능이므로 외부에서는 사용이 불가능하지만 Redux는 vue, angular 등 외부에서도 사용이 가능하다.
- Context API + useReducer는 낮은 규모와 빈도의 업데이트와 같은 정적인 상태의 전달에는 괜찮지만, Flux와 유사한 상태 전파의 대체물로는 부족하다.
- Context API - redux의 useSelector, styled-components의 themeProvider 등

<br>
<br>

### 🐬 Redux가 무엇인가요, 왜 Redux를 사용하시나요?

리덕스는 전역 상태 관리를 하기 위한 상태관리 라이브러리입니다.
**컴포넌트들의 데이터 교류가 복잡해질 때** 이를 효율적으로 관리하기 위해 리덕스를 사용합니다.
리덕스를 사용하면 상태값을 컴포넌트에 종속시키지 않고, 상태 관리를 컴포넌트의 바깥에서 관리할 수 있기 때문에 효율적인 상태관리가 가능해진다.

<br>

- 컴포넌트들의 데이터 교류가 복잡해질 때

  1. props drilling이 심할 때

  2. 여러 컴포넌트에서 접근해서 사용해야하는 상태값을 가질 경우

<br>
<br>

### 🐬 Redux 말고 다른 전역 상태관리 아는 것 하나와 차이점을 말해주세요.

- Redux는 Flux 아키텍처 기반(데이터 흐름이 단방향 )
- Recoil은 Atomic 모델 기반(Atom이라는 작은 상태 단위로 관리하고 Atom을 결합하여 데이터를 가공한다.)

<br>
<br>

#### 💡 3-1. Flux 아키텍처란?

- MVC 모델의 한계로 인해 생김

- flux 아키텍처의 데이터 흐름은 단방향이다.

- 데이터의 흐름은 dispatcher => store => view 순서이며 뷰에서 입력이 발생하면 action을 통해서 dispatcher로 향하게 된다.

![image](https://user-images.githubusercontent.com/72599761/204128681-99ddf4e5-fdb2-4910-98af-b40d925cb471.png)

##### - Dispatcher

dispatcher는 Flux 애플리케이션의 모든 데이터 흐름을 관리하는 일종의 허브 역할을 한다.
액션이 발생하면 디스패처로 메세지나 액션 객체가 전달이 되고, 디스패쳐에서는 이러한 메세지 혹은 액션 객체를 콜백함수를 통해 스토어로 전달한다. 스토어에 접근하기 위한 일종의 단계이고, 액션을 통해 접근하기 위해서는 디스패처의 단계를 거쳐야한다.

<br>

##### - Action

디스패처를 통해 스토어에 변화를 일으킬 수 있는데 이 때 디스패처의 데이터 묶음을 액션이라고 한다.

<br>

##### - Store

스토어는 애플리케이션의 상태를 저장 합니다. 모든 상태 변경은 스토어에 의해 결정되며 상태 변경을 위한 요청을 스토어에 직접 할 수는 없습니다. 상태 변경을 위해서는 꼭 액션 생성자를 통해 디스패쳐 단계를 거친 후 액션을 보내야만 상태값 변경이 가능합니다.

<br>
<br>

### 🐬 MVC 모델이란?

![image](https://user-images.githubusercontent.com/72599761/204128699-43124b80-a454-40b1-95ad-2ff69728e64f.png)

- controller, model, view로 이루어진 아키텍처
- Controller는 Model의 데이터를 조회하거나 업데이트하는 역할을 하고, Model은 이런 데이터를 View에 반영시킨다. 또 View는 사용자로부터 데이터를 입력받기도 하므로 사용자의 입력이 Model에 영향을 주기도 한다.
- 이러한 구조가 거대한 어플리케이션을 대상으로 한 프로젝트에 대해서는 복잡하고 빨라진다.

![image](https://user-images.githubusercontent.com/72599761/204128708-039cf642-8ce1-488f-a7c3-03085b3f18e4.png)

<br>

- 문제점 : 사용자와의 상호작용이 view에서 일어났기 때문에 model을 업데이트 해줘야하고, 의존하는 model이 있을 경우 그 model까지 업데이트를 해줘야 한다. 아주 많은 코드 변경이 발생한다.

<br>

- 해결 : 단방향 데이터 흐름을 택했다. 단방향 데이터 흐름을 가지는 구조는 데이터는 단방향으로만 흐르고, 새로운 데이터를 넣으면 처음부터 다시 시작되는 방식으로 설계되어있다. 이러한 시스템 구성을 Flux 구조라고 한다.

<br>
<br>

### 🐬 JSX가 무엇인가요?

JSX는 자바스크립트 코드를 HTML처럼 표현할 수 있는 React 엘리먼트를 생성하는 언어입니다.

<br>
<br>

### 🐬 virtual DOM이 무엇인가요? virtual DOM이 좋은 이유에 대해서 설명해주세요.

virtual DOM은 실제 DOM의 변화를 최소화시켜주는 역할을 합니다. virtual DOM을 사용하는 이유는 효율성 때문입니다. virtual DOM을 사용하면 실제 DOM을 바꾸는 것보다 시간복잡도가 낮아집니다. 만약, HTML파일에 20개의 변화가 생기면 과정 역시 20회가 이루어집니다. 하지만 virtual DOM은 변화된 부분만 가려내어 실제 DOM에 전달하기에 실제 DOM은 1회로 인식하여 단 한번의 렌더링 과정만 거치게 됩니다.

<br>
<br>

### 🐬 virtual DOM과 리얼 돔의 차이를 설명해주세요

- 리얼돔 : 웹 페이지를 이루는 태그들을 자바스크립트가 이용할 수 있게끔 브라우저가 트리구조로 만든 객체 모델을 의미한다.

- 가상돔 : 가상 DOM은 DOM의 상태를 메모리 위에 계속 올려두고, DOM에 변경이 있을 경우 해당 변경을 반영한다.

- 변경 전과 변경 후 가상 돔끼리 비교 후 바뀐 부분만 실제 돔에 적용된다.

  <br>

돔이란 Document Object Model 문서 객체 모델의 약자입니다. 문서객체란 Web browser 안에서 HTML 문서에 Javascript가 접근할 수 있도록 html 태그를 객체로 만든 것입니다.

여기서 문제점은 돔은 새로운 요청이나 변경사항이 있을 때마다 매번 리렌더링을 합니다. 매번 새롭게 구성하기 때문에 렌더할 양이 많아지면 속도가 느려지게 됩니다.

<br>

때문에 가상돔이 나왔습니다.
가상돔은 돔의 구조를 흉내낸 Javascript 객체(트리구조)입니다.
In-memory에 존재하기 때문에 실제로 렌더되지 않습니다.

리액트가 가상돔을 반영하는 절차를 보면, 변경사항이 있으면 UI를 가상돔에 리렌더링 합니다. 가상돔끼리 비교하고, 변경된 부분만 실제 돔에 적용시킵니다.

-

<br>
<br>

### 🐬 useRef에 대해 설명해보세요.

useRef는 저장공간(변수 관리) 이나 DOM 요소에 접근하기 위해 사용되는 훅입니다.

state 값을 바꿀 때 대표적으로 사용되는 훅이 useState인데, useRef는 ref 안에 값을 아무리 변경해도 컴포넌트는 다시 렌더링 되지 않습니다. 즉 state 대신 ref를 사용하면 불필요한 렌더링을 막을 수 있습니다. 또한 컴포넌트가 렌더링이 되어도 ref 안에 저장되어 있는 값은 변화되지 않고 그대로 유지가 됩니다. 이에 변경시 렌더링을 발생시키지 말아야 하는 값을 다룰 때 편리합니다.

<br>

DOM 요소 접근에 대해서는 보통 DOM에 접근해서 focus 하는 곳에 많이 사용한다. querySelector를 사용해서도 DOM 요소를 접근할 수 있지만, React에서 querySelector를 사용하게 되면, 실제 DOM의 요소를 가져오게 된다. 하지만 React는 Virtual DOM을 통해 Real DOM을 그리기 때문에, React가 제어하고 있는 Virtual DOM 안에 있는 요소에 접근할 수 있다.

<br>

- useRef는 저장공간(변수 관리)이나 DOM 요소에 접근하기 위해 사용되는 훅이다.
  - 저장공간(변수 관리) : 리렌더링 하지 않고, 컴포넌트의 속성만 조회 & 수정한다.
  - focus를 선택해주거나 텍스트의 선택 영역, 두개 컴포넌트의 싱크를 맞출 때 DOM을 직접적으로 건드려야할 때 사용한다.

<br>
<br>

### 🐬 useEffect의 실행 순서에 대해 설명해주세요.

useEffect는 bottom-top 방식으로 동작합니다. return 문이 읽히고 useEffect 훅이 읽힙니다.
즉 컴포넌트가 렌더링이 된 이후에 useEffect가 실행됩니다.

- useEffect는 컴포넌트가 렌더링이 된 후에 실행되는 것이다.
- 가장 하위에 있는 컴포넌트의 useEffect가 먼저 실행된다.

<br>
<br>

### 🐬 useEffect와 useLayoutEffect 차이에 대해 설명해주세요.

useEffect는 비동기로 함수가 실행되며, 렌더링이 된 이후에 동작하는 hook입니다. 반면, useLayoutEffect는 동기로 함수가 실행되며, 렌더링 되기 이전에 동작하는 hook입니다.

dom에서 동기적으로 리렌더링이 일어나면 앞선 작업이 끝나기 전까지 유저는 DOM에서 제대로 보지 못하게 됩니다. 이 때문에 비동기적으로 동작하는 useEffect를 먼저 사용해보는 것을 고려하는게 좋습니다.
단 동기적인 렌더링이 필요하거나 깜박임 등이 일어나면 useLayoutEffect를 제한적으로 고려해보는게 좋습니다.

- useEffect는 컴포넌트들이 render와 paint된 후 실행됩니다. 비동기적으로 실행됩니다.
- useLayoutEffect는 컴포넌트들이 render된 후 실행되며, 그 이후에 paint 됩니다. 이 작업은 동기적으로 실행됩니다.

<br>
<br>

### 🐬 useEffect 메소드로 componentWillUnmount 가 동작할 수 있는 방법에 대해서 설명하세요.

useEffect 코드 내부에서 return하는 익명함수를 작성하는 방법으로 componentwillUnmount를 구현할 수 있습니다.

```javascript
useEffect(() => {
  console.log('컴포넌트가 화면에 나타남');
  return () => {
    console.log('컴포넌트가 화면에서 사라짐');
  };
}, []);
```

- componentwillUnmount는 컴포넌트가 화면에서 사라질 때 나타나는 라이플사이클입니다.

<br>
<br>

### 🐬 메모이제이션을 하는 이유는?

- 메모이제이션 : 컴퓨터 프로그램이 동일한 계산을 반복해야할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술
- 메모이제이션을 하는 이유
  - 비싼 연산을 반복하는 것을 피하여 성능을 향상
  - 안정된 값을 제공한다.

<br>
<br>

### 🐬 웹 성능 향상을 위해 최적화를 해 본 경험이 있나요? 혹은 useMemo와 useCallback 메소드를 활용해 최적화하는 원리에 대해서 설명하세요.

useMemo와 useCallback은 성능 최적화를 위해서 사용되는 Hook입니다. 이때, useMemo는 특정 결과값을 재사용하는 반면에 useCallback은 특정함수를 새로 만들지 않고 재사용하고 싶을 때 사용합니다. 이 둘은 dependency 리스트를 이용하여 그 중 하나가 변경이 되면 결과에 대해 변경됩니다.

<br>
<br>

### 🐬 데이터 10,000개를 가지고 무한스크롤 구현시에 가장 중요하게 고려해야할 점은?

- 스크롤을 아주 많이 내려서 많은 이미지들이 DOM에 렌더링 되어있다면 이로 인한 성능 저하가 발생할 수 있다.
- React-virtualized를 사용하면, 실제 보이는 컴포넌트만 DOM에 렌더링하여 이러한 문제를 해결할 수 있다.

<br>
<br>

### 🐬 Context API란?

- 컴포넌트를 건너띄고 다른 컴포넌트에서 state, function을 사용할 수 있음

- redux의 많은 어려운 개념보다 context api는 Provider, Consumer, createContext 개념만 알면 적용가능

- context는 컴포넌트안에서 전역적으로 데이터를 공유하도록 나온 개념

  - 로그인 데이터, 웹 내 사용자가 쓰는 설정파일, 테마, 언어 등 다양하게 컴포넌트간 공유되어야할 데이터로 사용

<br>
<br>
