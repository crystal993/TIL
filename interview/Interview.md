# Interview 



## Frontend 

### 🐬 CSR(Client Side Rendering)과 SSR(Server Side Rendering)

#### >> SPA와 MPA 

 - SPA (Single Page Application)

   하나의 HTML 파일을 기반으로 자바스크립트를 이용해 동적으로 화면의 컨텐츠를 바꾸는 방식의 웹 어플리케이션이다. 

- MPA (Multiple Page Application)

  사용자가 페이지를 요청할 때마다, 웹 서버가 요청한 UI와 필요한 데이터를 HTML로 파싱해서 보여주는 방식의 웹 어플리케이션이다. 
  전통적인 방식을 이용한다면, SPA가 사용하는 렌더링 방식은 CSR이고, MPA가 사용하는 렌더링 방식은 SSR이다. 



- CSR 

  CSR에선 브라우저가 서버에 HTML과 JS파일을 요청한 후 로드되면 사용자의 상호작용에 따라 JS를 이용해서 동적으로 렌더링을 시킨다. 

  - 장점
    -  첫 로딩만 기다리면, 동적으로 빠르게 렌더링이 되기 때문에 사용자 경험(UX)이 좋다. 
  - 단점
    - 모든 스크립트 파일이 로드될 때까지 기다려야 한다. 
      - 리소스를 청크 단위로 묶어서 요청할 때만 다운 받게 하는 방식으로 완화시킬 수 있지만 완벽히 해결할 수는 없다. 
    - 검색엔진의 검색 봇이 크롤링을 하는데 어려움을 겪기 때문에 검색엔진 최적화(Search Engine Optimization)의 문제가 있다. 
      - 구글 봇의 경우는 JS를 지원하지만, 다른 검색엔진의 경우 그렇지 않기 때문에 문제가 된다. 

- SSR 

  SSR에선 브라우저가 페이지를 요청할 때마다 해당 페이지에 관련된 HTML, CSS, JS 파일 및 데이터를 받아와서 렌더링을 시킨다. 

  - 장점 
    - 초기 로딩 속도가 빠르기 때문에 사용자가 컨텐츠를 빨리 볼 수 있다. 
    - JS를 이용한 렌더링이 아니기 때문에 검색엔진 최적화가 가능하다. 

  - 단점 
    - 매번 페이지를 요청할 때마다 새로고침 되기 때문에 사용자 경험이 SPA에 비해서 좋지 않다. 
    - 서버에 매번 요청을 하기 때문에 서버의 부하가 커진다. 

<br>
<br>


### 🐬 브라우저 렌더링의 과정은? 

브라우저가 화면에 나타나는 요소를 렌더링 할 때, 웹킷(Webkit)이나 게코(Gecko) 등과 같은 **렌더링 엔진** 을 사용한다. 렌더링 엔진이 HTML, CSS, Javascript로 렌더링할 때 **CRP(Critical Rendering Path)** 라는 프로세스를 사용하며 다음 단계들로 이루어진다.

1. **HTML 파싱(해석) 후, DOM(Document Object Model) 트리 구축**
2. **CSS 파싱(해석) 후, CSSOM(CSS Object Model) 트리 구축**
3. Javascript 실행
   - 주의! HTML 중간에 스크립트가 있다면 HTML 파싱이 중단된다.
4. DOM과 CSSOM을 합쳐서 렌더트리(Render Tree) 구축
   - 주의! `display: none` 속성과 같이 화면에서 보이지도 않고 공간을 차지하지 않는 것은 렌더트리로 구축되지 않는다.
5. **뷰포트 내에서 렌더트리의 각 노드가 가지는 정확한 위치와 크기 계산 (Layout/Reflow 단계)**
6. **계산한 위치/크기를 기반으로 화면에 그림 (Paint 단계)**



**1.불러오기(Loading)**

HTTP 모듈 또는 파일 시스템으로 전달 받은 리소스 스트림을 읽는 과정으로 로더가 이 역할을 맡고 있다. 로더는 단순히 읽는 것이 아니라, 이미 데이터를 읽었는지도 확인하고, 팝업창을 열지 말지, 또는 파일 다운로드 받을지를 결정한다.

 

**2.다운받은 HTML, CSS를 Object Model로 만든다.**

**DOM**(Document Object Model) 이란?

HTML태그를 JS에서 이용할수 있는 객체로 만드는 것이다. 즉 HTML문서의 객체 기반 표현 방식이다.

◾ HTML -> DOM

HTML파일은 HTML파서에 의해 파싱 되어 DOM트리로 변환된다.

![image](https://user-images.githubusercontent.com/72599761/204128531-f1c06a29-3f6e-4435-87ce-af0020315032.png)


◾ CSS -> CSSOM (<link> ,<style> 를 통하여 생성)

CSS파일은 CSS파서에 의해 파싱 되어 CSSOM트리로 변환된다.

![image](https://user-images.githubusercontent.com/72599761/204128544-ecca39dc-1653-4d3b-a9a4-32d7d9651729.png)


**파싱(parse or parsing)?**

문서를 파싱한다는 것은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것이다.

파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리 또는 문법 트리 라고 부른다.

 

**3. DOM과 CSSOM을 합친다.**

◾Render Tree

![image](https://user-images.githubusercontent.com/72599761/204128547-bda612db-e097-4415-8706-4e78ba796f79.png)


**4. Layout**

렌더트리가 만들어 졌으면 이것을 토대로 그려질 노드와 그의 스타일값 그리고 치수까지 계산한다.

- Viewport : 그래픽이 표시되는 브라우저 영역, 크기. 뷰포트는 모바일의 경우 디스플레이의 크기, pc의 경우 브라우저 창의 크기에 따라 달라진다.

 

**5. Paint**

이 정보들을 페인팅 단계로 전달해서 렌더트리의 각 노드를 화면상의 실제 픽셀로 변환한다.

	
<br>
<br>


### 🐬 BOM과 DOM 

- BOM(Browser Object Model)

  브라우저의 창이나 프레임을 프로그래밍적으로 제어할 수 있게 해주는 객체 모델이다. 이를 통해서 브라우저의 새 창을 열거나 다른 문서로 이동하는 등의 기능을 실행시킬 수 있다. 전역 객체 window가 있으며 하위 객체들로 location, navigator, document, screen, history가 포함되어 있다.  

![image](https://user-images.githubusercontent.com/72599761/204128559-73ab0c21-1967-4a16-93bd-99ae173993ba.png)




- DOM(Document Object Model)

  웹페이지를 프로그래밍적으로 제어할 수 있게 해주는 객체모델이다. 최상위 인터페이스로 node가 있으며 이는 아래와 같은 구조로 나타난다. 


<br>
<br>


### 🐬 타입스크립트란?

- 자바스크립트의 경우는 동적 타입 언어(dynamic type language)이기 때문에 런타임 속도는 빠르지만 타입 안정성이 보장되지 않음
- 타입스크립트는 자바스크립트의 이러한 단점을 보완하기 위해서 만들어 짐 -> 이러한 이유로 MS에서는 타입스크립트에 “JavaScript that scales(확장된 자바스크립트)”라는 슬로건을 만듬
- 타입스크립트는 정적 타입 언어(static type language)이기 때문에 컴파일 시 시간이 조금 걸리더라도 안정성을 보장한다는 점이 장점

<br>
<br>

### 🐬 SEO란?

- SEO(검색 엔진 최적화)는 웹사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정
  - 검색 엔진은 웹을 크롤링 (en-US)하면서 페이지에서 페이지로 링크를 따라가고, 찾은 콘텐츠의 색인(검색 결과에 보이는 것)을 생성
  - 크롤러는 일정 규칙을 따르므로, SEO를 진행하며 해당 규칙을 밀접하게 따라가면 웹사이트가 검색 결과의 보다 높은 곳에 노출돼 (전자상거래와 광고라면) 수익으로 연결될 수도 있음

<br>
<br>


## React

### 🐬 리액트란? 

리액트는 UI 자바스크립트 라이브러리로서 싱글 페이지 어플리케이션의 UI를 생성하는 데 집중한 라이브러리입니다. 리액트는 자바스크립트에 HTML을 포함하는 JSX 문법과 단방향 데이터 바인딩을 사용하고 있습니다. 그리고 가상돔이라는 개념을 사용하여 웹 애플리케이션의 퍼포먼스를 최적화한 라이브러리입니다. 

<br>
<br>

### 🐬 리액트의 특징 

#### 1. 가상돔 (웹 애플리케이션의 성능을 극대화 )

- 리액트는 리플로우와 리페인트가 자주 수행되는 문제를 해결하기 위해 화면에 표시되는 DOM과 동일한 DOM을 메모리상에 만들고 DOM 조작이 발생하면 메모리상에 생성한 가상 돔에 모든 연산을 수행한 후, 실제 DOM을 갱신하여 리플로우/리페인트의 연산을 최소화했습니다. 

#### 2. 단방향 데이터 바인딩 

- 단방향 데이터 바인딩은 단 하나의 watcher가 자바스크립트의 데이터 갱신을 감지하여 사용자의 UI 데이터를 갱신합니다. 사용자가 UI를 통해 자바스크립트의 데이터를 갱신할 때는, 이벤트를 통해 갱신하게 됩니다. 이처럼 단방향 데이터 바인딩은 하나의 Watcher를 사용하기 때문에 양방향 데이터 바인딩이 가지는 성능적인 이슈를 해결하고 더 확실하게 데이터를 추적할 수 있게 해줍니다. (양방향 데이터 바인딩은 하나의 데이터 동기화에 두 개의 Watcher가 사용되고, 데이터가 많아지게 되면 이 데이터의 동기화를 위한 수많은 Watcher가 생성되므로 반대로 성능 저하가 발생할 수 있다. )

#### 3. JSX 

- JSX는 자바스크립트와 HTML을 동시에 사용하며, HTML에 자바스크립트의 변수들을 바로 사용할 수 있는 일종의 템플릿 언어 (Template language)입니다. 



#### 4. 선언형 프로그래밍 

- 프로그래밍에는 명령형 프로그래밍과 선언형 프로그래밍으로 구별할 수 있습니다. 명령형 프로그래밍은 프로그래밍을 할 때 어떻게(How)에 집중하는 것을 말하며 선언형 프로그래밍은 무엇(What)에 집중하여 프로그래밍을 하는 것을 말합니다. 



#### 5. 컴포넌트 기반 

- 컴포넌트는 재사용을 할 수 있으며 이런 재사용을 통해 개발 생산성을 향상시킬 수 있습니다. 또한 이렇게 작고 고립된 컴포넌트는 테스트 하기 쉬워 코드를 유지보수하는 데도 크게 도움이 됩니다. 

<br>
<br>

### 🐬 상태 관리를 왜 할까요? 그리고 평소에 state 관리는 어떻게 하시나요? 

상태관리란  웹 어플리케이션을 render하는데 있어 영향을 미칠 수 있는 값을 관리하는 것을 의미합니다.

상태관리를 하는 이유는 2가지가 있습니다. 

첫번째는 상태관리는 UI에 직/간접적으로 영향을 주게 됩니다. 따라서 상태를 제대로 관리하지 못하면 유저에게 어색한 경험을 제공하거나 버그가 생기게 됩니다. 

두번째는 리액트는 단방향 데이터 바인딩을 하므로 부모에서 자식 컴포넌트로만 데이터 전달이 가능합니다. props drilling이 심할 때나 여러 컴포넌트에서 접근해서 사용하는 상태 값을 가질 경우에 유지보수가 어려워지고, 이를 해결하기 위해 상태관리가 필요합니다. 

평소에 모달창을 열고 닫는 상태값처럼 한 컴포넌트 내에서 상태값 관리가 가능하면 useState로 상태관리를 하고, 단순 props drilling이 심할 때나 적당히 복잡한 컴포넌트가 존재하고, 외부 라이브러리를 쓰고 싶지 않을 때는 context와 useReducer 조합을 사용합니다. 특정 구성 요소만 re-render 시키거나, 사이드 이펙트를 줄이기 위해서  redux toolkit을 사용하여 관리합니다. 

<br>

- 상태란? 웹 어플리케이션을 render하는데 있어 영향을 미칠 수 있는 값이다.

- 상태관리란? 웹 어플리케이션을 render하는데 있어 영향을 미칠 수 있는 값을 관리하는 것을 의미

- 상태의 종류? 전역 상태, 컴포넌트 간의 상태, 지역 상태 

- 상태관리는 왜 필요할까? 

  1. UI에 직/간접적으로 영향을 주기 때문에 => 유저에게 어색한 경험, 버그 발생 

  2.  리액트는 단방향 데이터 바인딩을 하므로 부모에서 자식컴포넌트로만 데이터 전달이 가능하다. props drilling이 심할 때나 여러 컴포넌트에서 접근해서 사용하는 상태값을 가질 경우에 유지보수가 어려워진다. 이를 해결하기 위해 상태관리가 필요하다. 

<br>

- 나의 상태관리 

  1. useState 

     : 모달창을 열고 닫는 상태값처럼 한 컴포넌트 내에서 상태값 관리가 가능할 때 사용

  2. context와 useReducer 조합 

     : 단순 props drilling이 심할 때나 적당히 복잡한 컴포넌트가 존재할 때, 낮은 빈도의 업데이트와 같은 정적인 상태의 전달, 외부 라이브러리를 쓰고 싶지 않을 때 사용 

  3. redux-toolkit 

     : 2번보다 강력한 기능이 필요할 때! props drilling도 심하고 굉장히 복잡한 컴포넌트 구조이거나 저장소 상태의 특정 부분만 사용하고, 해당 값을 re-render 시키거나, 사이드 이펙트를 줄이기 위해서 사용. 

<br>     

(useReducer는 context내부에 포함된 컴포넌트들이 상태값의 일부에만 관심있더라도 강제로 re-render되므로 성능문제 발생. useReducer는 미들웨어도 존재하지 않는다. )


<br>
<br>


#### 💡 1-1. props drilling이란? 

리액트는 대표적으로 단방향 데이터흐름 이라는 특징이 있습니다. 이는 data를 전달 할 때 부모 컴포넌트에서 자식 컴포넌트로만 데이터 전달이 가능합니다. 예를 들어 부모컴포넌트에서 props를 통해 최하위 자식컴포넌트로 데이터를 전달해야할 때, 중간 컴포넌트는 그 데이터가 필요하지 않음에도 불구하고 props를 전달하는 과정을 props drilling이라고 합니다. 

- Props drilling으로 발생하는 문제점

  - 여러개의 컴포넌트를 타고 내려가다 보면 props의 지옥이 펼쳐지고 이 props가 도대체 어디서부터 시작된건지 타고 올라가는 것이 쉽지 않습니다. 이 때문에 유지 보수 또한 어려워진다. 

  - ⭐ props를 통해 여러번 전달되는 데이터가 전달되는 경우 실제 변화가 적용되어야 하는 컴포넌트 뿐만 아니라 전달 경로에 있는 컴포넌트들도 리렌더하는 문제가 발생합니다.


<br>
<br>


#### 💡 1-2. Context API와 Redux의 차이 

- context + useReducer는 context를 통해 현재 상태값을 전달하는데 의존한다. Redux는 Context를 통해 현재 Redux 스토어 인스턴스를 전달한다. 
- useReducer는 context내부에 포함된 컴포넌트들이 상태값의 일부에만 관심있더라도 강제로 re-render되므로 성능문제 발생. useReducer는 미들웨어도 존재하지 않는다. 
- Redux를 사용하면 저장소 상태의 특정 부분만 사용하고 해당 값이 변경될 때만 re-render 한다. 

- Context, useReducer는 React에 내장되어 있는 기능이므로 외부에서는 사용이 불가능하지만 Redux는 vue, angular 등 외부에서도 사용이 가능하다. 
- Context API + useReducer는 낮은 규모와 빈도의 업데이트와 같은 정적인 상태의 전달에는 괜찮지만, Flux와 유사한 상태 전파의 대체물로는 부족하다. 
- Context API - redux의 useSelector, styled-components의 themeProvider 등 

<br>
<br>

### 🐬 Redux가 무엇인가요, 왜 Redux를 사용하시나요?

리덕스는 전역 상태 관리를 하기 위한 상태관리 라이브러리입니다. 
**컴포넌트들의 데이터 교류가 복잡해질 때** 이를 효율적으로 관리하기 위해 리덕스를 사용합니다. 
리덕스를 사용하면 상태값을 컴포넌트에 종속시키지 않고, 상태 관리를 컴포넌트의 바깥에서 관리할 수 있기 때문에 효율적인 상태관리가 가능해진다. 

<br>

- 컴포넌트들의 데이터 교류가 복잡해질 때  

  1. props drilling이 심할 때

  2. 여러 컴포넌트에서 접근해서 사용해야하는 상태값을 가질 경우

<br>
<br>

### 🐬 Redux 말고 다른 전역 상태관리 아는 것 하나와 차이점을 말해주세요. 

- Redux는 Flux 아키텍처 기반(데이터 흐름이 단방향 )
- Recoil은 Atomic 모델 기반(Atom이라는 작은 상태 단위로 관리하고 Atom을 결합하여 데이터를 가공한다.)


<br>
<br>


#### 💡 3-1. Flux 아키텍처란?

- MVC 모델의 한계로 인해 생김 

- flux 아키텍처의 데이터 흐름은 단방향이다.  

- 데이터의 흐름은 dispatcher => store => view 순서이며 뷰에서 입력이 발생하면 action을 통해서 dispatcher로 향하게 된다. 

![image](https://user-images.githubusercontent.com/72599761/204128681-99ddf4e5-fdb2-4910-98af-b40d925cb471.png)

##### - Dispatcher 

dispatcher는 Flux 애플리케이션의 모든 데이터 흐름을 관리하는 일종의 허브 역할을 한다. 
액션이 발생하면 디스패처로 메세지나 액션 객체가 전달이 되고, 디스패쳐에서는 이러한 메세지 혹은 액션 객체를 콜백함수를 통해 스토어로 전달한다. 스토어에 접근하기 위한 일종의 단계이고, 액션을 통해 접근하기 위해서는 디스패처의 단계를 거쳐야한다. 

<br>

##### - Action 

디스패처를 통해 스토어에 변화를 일으킬 수 있는데 이 때 디스패처의 데이터 묶음을 액션이라고 한다. 

<br>

##### - Store

스토어는 애플리케이션의 상태를 저장 합니다. 모든 상태 변경은 스토어에 의해 결정되며 상태 변경을 위한 요청을 스토어에 직접 할 수는 없습니다. 상태 변경을 위해서는 꼭 액션 생성자를 통해 디스패쳐 단계를 거친 후 액션을 보내야만 상태값 변경이 가능합니다.


<br>
<br>
	

### 🐬 MVC 모델이란? 

![image](https://user-images.githubusercontent.com/72599761/204128699-43124b80-a454-40b1-95ad-2ff69728e64f.png)

- controller, model, view로 이루어진 아키텍처 
- Controller는 Model의 데이터를 조회하거나 업데이트하는 역할을 하고, Model은 이런 데이터를 View에 반영시킨다. 또 View는 사용자로부터 데이터를 입력받기도 하므로 사용자의 입력이 Model에 영향을 주기도 한다. 
- 이러한 구조가 거대한 어플리케이션을 대상으로 한 프로젝트에 대해서는 복잡하고 빨라진다. 

![image](https://user-images.githubusercontent.com/72599761/204128708-039cf642-8ce1-488f-a7c3-03085b3f18e4.png)

<br>

- 문제점 : 사용자와의 상호작용이 view에서 일어났기 때문에 model을 업데이트 해줘야하고, 의존하는 model이 있을 경우 그 model까지 업데이트를 해줘야 한다. 아주 많은 코드 변경이 발생한다. 

<br>

- 해결 : 단방향 데이터 흐름을 택했다. 단방향 데이터 흐름을 가지는 구조는 데이터는 단방향으로만 흐르고, 새로운 데이터를 넣으면 처음부터 다시 시작되는 방식으로 설계되어있다. 이러한 시스템 구성을 Flux 구조라고 한다. 


<br>
<br>


### 🐬 버츄얼 돔과 리얼 돔의 차이를 설명해주세요 

돔이란 Document Object Model 문서 객체 모델의 약자입니다. 문서객체란 Web browser 안에서 HTML 문서에 Javascript가 접근할 수 있도록 html 태그를 객체로 만든 것입니다. 

여기서 문제점은 돔은 새로운 요청이나 변경사항이 있을 때마다 매번 리렌더링을 합니다. 매번 새롭게 구성하기 때문에 렌더할 양이 많아지면 속도가 느려지게 됩니다. 

<br>

때문에 가상돔이 나왔습니다. 
가상돔은 돔의 구조를 흉내낸 Javascript 객체(트리구조)입니다. 
In-memory에 존재하기 때문에 실제로 렌더되지 않습니다. 

리액트가 가상돔을 반영하는 절차를 보면, 변경사항이 있으면 UI를 가상돔에 리렌더링 합니다. 가상돔끼리 비교하고, 변경된 부분만 실제 돔에 적용시킵니다. 

<br>

- 리얼돔 : 웹 페이지를 이루는 태그들을 자바스크립트가 이용할 수 있게끔 브라우저가 트리구조로 만든 객체 모델을 의미한다. 
- 가상돔 : 가상 DOM은 DOM의 상태를 메모리 위에 계속 올려두고, DOM에 변경이 있을 경우 해당 변경을 반영한다.
- 변경 전과 변경 후 가상 돔끼리 비교 후 바뀐 부분만 실제 돔에 적용된다.  


<br>
<br>
	

### 🐬  useRef에 대해 설명해보세요. 

useRef는 저장공간(변수 관리) 이나 DOM 요소에 접근하기 위해 사용되는 훅입니다. 

state 값을 바꿀 때 대표적으로 사용되는 훅이 useState인데, useRef는 ref 안에 값을 아무리 변경해도 컴포넌트는 다시 렌더링 되지 않습니다. 즉 state 대신 ref를 사용하면 불필요한 렌더링을 막을 수 있습니다. 또한 컴포넌트가 렌더링이 되어도 ref 안에 저장되어 있는 값은 변화되지 않고 그대로 유지가 됩니다. 이에 변경시 렌더링을 발생시키지 말아야 하는 값을 다룰 때 편리합니다. 

<br>

DOM 요소 접근에 대해서는 보통 DOM에 접근해서 focus 하는 곳에 많이 사용한다. querySelector를 사용해서도 DOM 요소를 접근할 수 있지만, React에서 querySelector를 사용하게 되면, 실제 DOM의 요소를 가져오게 된다. 하지만 React는 Virtual DOM을 통해 Real DOM을 그리기 때문에, React가 제어하고 있는 Virtual DOM 안에 있는 요소에 접근할 수 있다. 

<br>

- useRef는 저장공간(변수 관리)이나 DOM 요소에 접근하기 위해 사용되는 훅이다. 
  - 저장공간(변수 관리) : 리렌더링 하지 않고, 컴포넌트의 속성만 조회 & 수정한다. 
  - focus를 선택해주거나 텍스트의 선택 영역, 두개 컴포넌트의 싱크를 맞출 때 DOM을 직접적으로 건드려야할 때 사용한다. 

<br>
<br>


### 🐬  useEffect의 실행 순서에 대해 설명해주세요.

useEffect는 bottom-top 방식으로 동작합니다. return 문이 읽히고 useEffect 훅이 읽힙니다. 
즉 컴포넌트가 렌더링이 된 이후에 useEffect가 실행됩니다. 

- useEffect는 컴포넌트가 렌더링이 된 후에 실행되는 것이다. 
- 가장 하위에 있는 컴포넌트의 useEffect가 먼저 실행된다. 

<br>
<br>


### 🐬  useEffect와 useLayoutEffect 차이에 대해 설명해주세요. 

useEffect는 비동기로 함수가 실행되며, 렌더링이 된 이후에 동작하는 hook입니다. 반면, useLayoutEffect는 동기로 함수가 실행되며, 렌더링 되기 이전에 동작하는 hook입니다. 

dom에서 동기적으로 리렌더링이 일어나면 앞선 작업이 끝나기 전까지 유저는 DOM에서 제대로 보지 못하게 됩니다. 이 때문에 비동기적으로 동작하는 useEffect를 먼저 사용해보는 것을 고려하는게 좋습니다. 
단 동기적인 렌더링이 필요하거나 깜박임 등이 일어나면 useLayoutEffect를 제한적으로 고려해보는게 좋습니다. 

- useEffect는 컴포넌트들이 render와 paint된 후 실행됩니다. 비동기적으로 실행됩니다. 
- useLayoutEffect는 컴포넌트들이 render된 후 실행되며, 그 이후에 paint 됩니다. 이 작업은 동기적으로 실행됩니다. 

<br>
<br>

### 🐬 메모이제이션을 하는 이유는? 

- 메모이제이션 : 컴퓨터 프로그램이 동일한 계산을 반복해야할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술 
- 메모이제이션을 하는 이유 
  - 비싼 연산을 반복하는 것을 피하여 성능을 향상 
  - 안정된 값을 제공한다.  

<br>
<br>


### 🐬  데이터 10,000개를 가지고 무한스크롤 구현시에 가장 중요하게 고려해야할 점은? 

- 스크롤을 아주 많이 내려서 많은 이미지들이 DOM에 렌더링 되어있다면 이로 인한 성능 저하가 발생할 수 있다. 
- React-virtualized를 사용하면, 실제 보이는 컴포넌트만 DOM에 렌더링하여 이러한 문제를 해결할 수 있다. 


<br>
<br>

###  🐬 Context API란?

- 컴포넌트를 건너띄고 다른 컴포넌트에서 state, function을 사용할 수 있음

- redux의 많은 어려운 개념보다 context api는 Provider, Consumer, createContext 개념만 알면 적용가능

- context는 컴포넌트안에서 전역적으로 데이터를 공유하도록 나온 개념

  - 로그인 데이터, 웹 내 사용자가 쓰는 설정파일, 테마, 언어 등 다양하게 컴포넌트간 공유되어야할 데이터로 사용

    
<br>
<br>
	

## Javascript

### 🐬 Javascript 언어의 특징

- 크로스 플랫폼 언어
- 클라이언트 측 및 서버 측에 널리 사용됩니다.
- 컴파일 과정이 따로 필요가 없으며 바로 화면에 적용 가능
- 인터프리터 언어 (클라이언트의 웹 브라우저에 의해 해석되고 실행된다.)
- 객체 기반의 스크립트 언어
- 이벤트 기반의 프로그래밍 언어
- 단일 스레드 

#### 장점

1. 웹 브라우저에서 동작하는 스크립트 언어로 운영체제의 제한을 받지 않는다.
2. 컴파일 과정이 없기 때문에 다른 언어와 비교했을 때 빠른 시간 안에 스크립트 코드 작성 가능 (HTML 파일 내에 작성할 수 있으므로 개발 속도 빠름)
3. 웹 서버에 주는 부담이 적다.
4. 러닝 커브가 낮다.

#### 단점

- 브라우저 상에 소스가 노출되어서 보안에 취약
- 브라우저 상에서 소스 변경 가능. 사용자가 임의로 기능을 실행하거나 악용할 가능성이 있다.
- 한정된 객체와 객체 함수 제공
- 다중 프로세서 다중 스레딩 기능이 없다.

<br>
<br>


### 🐬 Javascript 언어의 특징

1. String

2. Number

3. Boolean

4. Symbol

5. Null

6. Undefined

<br>
<br>

### 🐬 undefined와 null의 차이점

undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다. 그래서 변수를 참조했을때 undefined가 반환된다면 초기화하지 않은 변수라는 것을 알 수 있다.

null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. (의도적 부재) 이는 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미하며, 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행한다.

<br>
<br>

### 🐬 ==와 ===의 차이점


- 동등 비교(==)     연산자는 좌항과 우항을 비교할 때, 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교한다. 따라서     타입이 다르더라도 암묵적 타입 변환 후에 같은 값이라면 true를 반환한다.
- 일치     비교(===) 연산자는 좌항과 우항의 피연산자가 타입이 같고, 값이 같은 경우에 한하여 true를 반환한다. ⇒ 동등비교(==)는 예측하기 어려운 결과를 만들어내므로, 일치 비교(===) 연산자를 사용하는 것이     권장된다.

<br>
<br>



### 🐬 var, let, const의 차이에 대해 알려주세요. 



![image](https://user-images.githubusercontent.com/72599761/204128739-402676c6-c324-40b2-b8ff-8bf9ce335853.png)

<br>


- var : 변수 재선언, 재할당 모두 가능하다, 함수레벨 스코프 
- let : 변수 재선언은 불가능, 재할당 가능(immutable true), 블록레벨 스코프 
- const: 변수 재선언, 재할당 불가능(immutable false), 블록레벨 스코프 

<br>
<br>

##### ⚠️ const의 주의할 점 

상수는 재할당이 안된다고 했지만, const로 된 객체의 속성들은 수정될 수 있다. 

- 기본형과 참조형의 개념을 알아야 하는데, 간단하게 설명하면 원시값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어있는 참조값을 통해 실제 객체에 접근한다. 
- 원시값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없지만, 객체는 변경이 가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 변경하는 것이 가능하다. 
- 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고, 프로퍼티의 값을 갱신할 수도 있으며 프로퍼티를 삭제할 수 도 있다. 

 
<br>
<br>


#### 💡 9-1. 변수 호이스팅이란? 

- var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어올려진 것처럼 동작한다. 
- var 키워드로 선언한 변수는 변수 선언이 런타임에서 되는 게 아니라 그 이전단계에서 먼저 실행되기 때문에 변수 선언문 이전에 참조할 수 있다. 
- 할당문 이전에 변수를 참조하면, 언제나 undefined를 반환하게 된다. 

```javascript
// 1. 선언 단계 : 변수 호이스팅에 의해 foo변수가 선언되었다. 
// 2. 초기화 단계 : 변수 foo는 undefined로 초기화된다. 
console.log(foo); // undefined

// 3. 할당 단계
foo = 123;

console.log(foo); //123
```


<br>



⚠️ 변수 선언문 이전에 변수를 참조하는 것은 호이스팅에 의해 에러를 발생시키지는 않지만 가독성을 떨어뜨리고 오류를 발생시킬 여지가 있다. 

<br>

👉 var 키워드의 위와 같은 단점을 보완하여 ES6 문법에서는 let, const가 등장하게 되었습니다. 

<br>
	<br>

### 🐬  Async/Await과 Promise의 차이 

Promise를 활용할 시에는 .catch()문을 통해 에러 핸들링이 가능하지만, async/await은 에러 핸들링을 할 수 있는 기능이 없어 try-catch()문을 활용해야 합니다. 그리고 Promise는 .then 지옥의 가능성이 있는 반면에 async/await을 활용한 코드는 가독성이 좋습니다. async/await은 비동기 코드가 동기코드 처럼 읽히게 해주며 코드 흐름을 이해하기 쉽게 해줍니다. 



- 에러 핸들링 
  - Promise를 활용할 시에는 .catch()문을 통해 에러핸들링이 가능하지만, async/await은 에러 핸들링을 할 수 있는 기능이 없어 try-catch() 문을 활용
- 코드 가독성 
  - Promise의 .then() 지옥의 가능성 
  - 코드가 길어지면 길어질수록, async/await를 활용한 코드가 가독성이 좋다. 
  - async/await은 비동기코드가 동기 코드처럼 읽히게 해준다. 코드 흐름을 이해하기 쉽다. 


<br>
<br>
	

### 🐬 동기와 비동기의 차이점 

- 동기는 서버에서 요청을 보냈을 때 응답이 돌아와야 다음 동작을 수행하는 것이 가능합니다. 
- 비동기는 반대로 요청을 보냈을 때 응답 상태와 상관없이 다음 동작을 수행할 수 있습니다. 

<br>
<br>


### 🐬 closure란? 

- 외부함수에 접근할 수 있는 내부함수 혹은 이러한 원리를 일컫는 용어인데 
- 스코프에 따라서 내부함수의 범위에서는 외부 함수 범위에 있는 변수에 접근이 가능하지만 
- 그 반대는 실현이 불가능하다는 개념이다. 

- 반복문과 비동기 함수가 만날 때 문제가 자주 발생하는데, 클로저의 특성을 사용해서 해결할 수 있습니다. 

<br>
<br>


### 🐬 Javascript Event Loop 

자바스크립트 엔진은 실행될 코드를 콜스택으로 할당해서 실행하게 됩니다. 동기적인 코드가 먼저 실행이 되는데요. 그 동안 비동기 코드들 같은 경우에는 웹 API의 처리를 거치게 됩니다. 그리고 콜백큐에 담아집니다. 그리고 동기 함수의 처리가 끝나고 비동기 함수가 처리될 때 이벤트 루프는 콜백튜에 할당된 함수들을 순서에 맞춰 콜스택에 할당해주고 실행됩니다. 

<br>
<br>

### 🐬 Promise와 Callback의 차이점은

- callback을 사용하면 비동기 로직의 결과값을 처리하기 위해서는 callback안에서만 처리를 해야하고, 콜백 밖에서는 비동기에서 온 값을 알 수가 없음
- 하지만 promise를 사용하면 비동기에에서 온 값이 promise 객체에 저장되기 때문에 코드 작성이 용이

<br>
<br>


###  🐬 Cors가 무엇이며 어떻게 해결 가능한가? 

다른 도메인에서 리소스 요청시 cross-origin HTTP에 의해 요청을 하는데, 대부분의 브라우저는 보안 상의 이유로 이 요청을 제한한다. 이를 동일 오리진 정책 (Same Origin Policy) 이라고 한다. 

 <br>

요청을 보내기 위해서 요청 보내는 대상과 프로토콜이 같아야하고, 포트도 같아야한다. JSONP을 통해 해결하거나 특정 HTTP 헤더를 추가하여 이 이슈를 해결할 수 있다. 이와 같이 타 도메인 간 자원을 공유할 수 있게 해주는 것을 Cross Origin Resourse Sharing, 줄여서 cors라고 한다.

<br>
<br>

### 🐬 크로스 브라우징이란? 

크로스 브라우징은 웹 표준에 따라 서로 다른 os 또는 플랫폼에 대응하는 것을 말한다. 브라우저별 렌더링 엔진이 다른 상황 등 어떠한 상황 속에서도 문제없이 동작하게 하는 것을 목표로 한다.


<br>
<br>


### 🐬 이벤트 버블링이란? 

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작합니다. 

<br>
<br>


### 🐬 부모에서 자식으로 이벤트를 상속하는 방법 

- 이벤트 캡쳐링으로 부모에서 자식으로 이벤트를 상속하는 것이 가능하다. 
- 이벤트 캡쳐링은 이벤트 버블링과 반대로 상위 요소에서 하위 요소로 탐색하며 이벤트를 전파하는 방식이다. (부모 -> 자식)

<br>
<br>

### 🐬 이벤트 버블링을 활용하는 방법 

- 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소릐 이벤트들을 제어하는 방식으로 이벤트 버블링을 활용 (이벤트 위임)
- 이벤트 버블링을 응용하여 부모 엘리먼트에 리스너를 위임하여 부착하면, 리스너의 개수를 1개로 줄여 최적화 가능 

<br>
<br>


### 🐬 React, 왜 사용하시나요? 

- SPA 
- React native 앱 개발이 가능 
- 수많은 커뮤니티가 존재 
- 컴포넌트 재사용 가능 (유지보수 용이)

<br>
<br>

## 웹 (WEB) 

### 🐬 HTTP 

클라이언트-서버 모델을 따르는 프로토콜로 TCP/IP 위에서 동작하며 80번 포트를 사용하여 통신한다. 첫번째 표준은 HTTP/1.1이며 이후로 HTTP/2 및 HTTP/3가 등장하였다. 여기선 HTTP/1.1의 내용을 정리한다. 

<br>
<br>

### 🐬 HTTP의 특징 

1. 비연결지향 (Connectionless)

   클라이언트가 서버에게 리소스를 요청한 후 응답을 받으면 연결을 끊어버리는 특징이다. 연결을 유지하게 되면 서버에 많은 부담을 줄 수 있기 때문에 상당히 많은 클라이언트에게 요청을 받는 웹서버의 경우 응답을 처리했으면 연결을 끊는다. 이로 인해 서버의 부담을 줄일 수 있지만, 리소스를 요청할 때마다 연결해야 하는 오버헤드 비용이 발생한다. 이를 해결하기 위해선, 요청 헤더의 `Connection: keep-alive` 속성으로 지속적 연결 상태(Persistent connection)를 유지할 수 있다. 즉, 요청을 할 때마다 연결하지 않고 기존의 연결을 재사용하는 방식이다. HTTP 1.1 부턴 지속적 연결 상태가 기본이며 이를 해제하기 위해선 명시적으로 요청 헤더를 수정해야 한다.

2. 무상태성 

   각각의 요청이 독립적으로 여겨지는 특징으로, 서버는 클라이언트의 상태를 유지하지 않는다. 즉, 각 클라이언트에 맞게 리소스를 응답하는 것은 불가능하다. 이를 해결하기 위해 쿠키나 세션 또는 토큰 방식의 OAuth 및 JWT가 사용된다. 

<br>
<br>

### 🐬 ★ HTTP Method 

클라이언트가 서버에 요청방법을 정의하는 것으로 주어진 리소스에 수행하길 원하는 행동을 나타낸다. 

- **GET**: 서버에게 조회할 리소스를 요청한다. (Read, 조회)
- **POST** : 서버에게 본문(body)에 생성할 데이터를 삽입하여 전송한다. (CREATE, 생성)
- **PUT** : 서버에게 본문에 수정할 데이터를 삽입하여 전송한다. (UPDATE, 수정)
- **DELETE** : 서버에게 삭제할 리소스를 요청한다. (DELETE, 삭제)
- **PATCH** : PUT과 비슷하지만 일부만 수정한다는 점에서 다르다.

<br>
<br>

### 🐬 HTTP 응답 상태코드 

서버가 클라이언트에게 요청을 받으면 응답상태에 따라서 다른 상태코드를 클라이언트에게 돌려준다. 

- **1xx (요청에 대한 정보)** : 요청을 받았으면 작업을 계속한다.
- 2xx (성공) : 요청을 성공적으로 수행했다.
  - 200(성공), 201(새 리소스 작성), 202(요청 접수, 아직 처리는 안함)
- 3xx (리다이렉션) : 클라이언트가 요청을 마지기 위해 추가적인 동작을 취해야 한다.
  - 300(여러개의 응답, 선택해야 함), 301(영구이동, 요청한 페이지가 영구적으로 이동됨), 302(임시이동, 현재 응답잉 다른 페이지이긴 하지만 임시적임)
- 4xx (클라이언트 오류) : 클라이언트에 오류가 있다.
  - 401(권한 없음), 403(금지됨, 리소스에 대한 권한 없음), 404(찾을 수 없음, 서버에 없는 페이지)
- 5xx (서버 오류) : 서버에 오류가 있다.
  - 500(내부 서버오류), 501(요청수행 기능없음, 메서드 인식불가), 503(서비스 사용불가)

<br>
<br>

### 🐬 HTTPS 란? 

- HTTPS (HTTP Secure)는 HTTP protocol의 암호화된 버전 
- 클라이언트와 서버간의 모든 커뮤니케이션을 암호화하기 위하여 SSL이나 TLS를 사용한다. 
  - SSL 인증서
    - SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화
  - TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지함
    - TSL은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공
- 이 커넥션은 클라이언트가 민감한 정보를 서버와 안전하게 주고받도록 해준다. 

![image](https://user-images.githubusercontent.com/72599761/204128764-81021f2c-3db3-422c-90e6-bebc8670dd5b.png)


HTTPS(HyperText Transfer Protocol over TLS/SSL)는 **기존의 HTTP를 암호화한 프로토콜** 로 보안이 강화된 버전이다. 약어에서의 "S"가 원래 SSL(Secure Socket Layer)의 약자였지만 SSL 버전 3.1부터 TLS(Transport Layer Security)로 명칭이 바뀌고 TLS와 혼용하고 있다. TCP의 연결이 이루어진 후 TLS를 통해 암호화 설정이 되고 통신을 하는 방식이다.

<br>
<br>

### 🐬 브라우저에서 주소창에 url 입력시 어떤일이 일어나는가?

1. 웹 브라우저에 URL을 입력하고 Enter 키를 누릅니다. 
2. 웹 브라우저가 도메인명의 IP 주소 조회 
3. 웹 브라우저가 서버와의 TCP 연결 시작 
4. 웹 브라우저가 HTTP 요청을 서버로 전송 
5. 웹 서버가 요청을 처리하고 응답을 다시 전송 
6. 웹 브라우저가 콘텐츠 렌더링 

<br>
<br>

### 🐬 URI vs URL 

![image](https://user-images.githubusercontent.com/72599761/204128774-1ec65148-38fa-4adb-a809-de0072e90540.png)


- URL : 서버에 있는 파일의 위치 
- URI : 서버에 있는 자원의 위치 

<br>
<br>


### 🐬 RESTFul API란? 

- RESTFul은 REST의 설계 규칙을 잘 지켜서 설계된 API를 RESTful한 API 
  - REST API : REST의 특징을 기반으로 서비스 API를 구현한 것 
  - 각 요청이 어떤 동작이나 정보를 위한 것인지를 그 요청의 모습 자체로 추론이 가능한 것 
  - URI는 정보의 자원을 표현 / 자원에 대한 행위는 HTTP Method(GET, POST, PUT, PATCH, DELETE)로 표현 / 행위는 URI에 포함하지 않음 

<br>
<br>

### 🐬 GET, POST 방식의 차이점

- GET, POST 방식 모두 브라우저가 서버에 요청하는 것 
- GET, POST 방식 차이점 
  - GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용한다. 
  - GET은 URL 파라미터에 요청하는 데이터를 담아보내기 때문에 HTTP 메세지에 body가 없으나, POST는 body에 데이터를 담아 보내기 때문에 당연히 HTTP 메시지에 body가 존재 
    - GET 요청은 멱등이며, POST는 멱등이 아님 
      - 멱등성 : 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질

<br>
<br>

### 🐬 AJAX란 무엇인가

- Asynchronous JavaScript and XML의 약자
- 빠르게 동작하는 동적인 웹 페이지를 만들기 위한 개발 기법의 하나
- Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있음. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹 페이지의 일부분에만 표시 가능

<br>
<br>

### 🐬 프레임워크 vs 라이브러리 

프레임워크는 프로그램의 흐름 자체를 개발자가 아닌 프로그램이 갖지만, 라이브러리는 흐름에 대한 제어를 하지 않고 개발자가 필요한 부분만 가져와서 사용하는 형태가 라이브러리입니다.  즉, 제어권이 프로그램에게 있으면 프레임워크, 개발자가 제어권을 갖고 있으면 라이브러리이다. 

<br>
<br>

## 네트워크 (Network)

### 🐬 TCP란 무엇인가?

- 인터넷 상에서 데이터를 메시지 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다. (Transmission Control Protocol)

- TCP (전송 제어 프로토콜)은 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜 
- TCP는 에러 없이 패킷이 신뢰할 수 있게 전달되었는지 보증해주는 것이다. 
- TCP는 동시제어가 가능하다 -> 이는 초기 요청이 작게 시작해도 컴퓨터들과 서버들의 대역폭의 깊이가 증가해도 네트워크가 지원할 수 있다는 것을 뜻한다. 



- 패킷이란? 
  - 인터넷 내에서 데이터를 보내기 위한 경로 배정을 효율적으로 하기 위해서 데이터를 여러개의 조각들로 나누어 전송을 하는데 이 때 이 조각을 패킷이라고 한다. 

<br>
<br>

### 🐬 TCP와 UDP의 차이점은? 

TCP는 신뢰성있는 통신을 위해 사용하는 프로토콜로 높은 신뢰성을 보장하지만, UDP보다는 속도가 느립니다. 3 Way, 4Way handshake로 서버와 클라이언트가 1:1로 통신을 합니다. 흐름 제어와 혼잡 제어가 이루어지게 됩니다. 

UDP는 비연결형 프로토콜로, 손상된 데이터에 대해서 재전송하지 않는 특징을 가지고 있습니다. 신뢰성이 낮지만, TCP보다 속도가 빨라서 스트리밍 같은 서비스에 주로 사용됩니다. 마지막으로 1:1, 1:N, N:N으로 연결이 가능합니다. 



- TCP : 신뢰성이 높은 프로토콜이다. 

  - 신뢰성이란 무엇인가, 내가 전달한 것이 보장된다는 의미이다. 상대방이 받았는지 확인할 수 있음. 

  - 느리다.

  - 3 Way Hand Shaking 

  - 흐름제어

  - 혼잡제어 

 

- UDP: 빠른 프로토콜이다. 
  - 일대일 일대다 통신



![image](https://user-images.githubusercontent.com/72599761/204128795-9dc4657f-576d-41aa-b6ec-2fd8bf2e187b.png)


<br>
<br>

### 🐬 OSI 7 계층이란? 

OSI 7계층은 인터넷 환경에서 통신하기 위해 네트워킹에 대한 표준을 7계층으로 나눈 것입니다. 

크게 7계층이 있습니다. 물리계층, 데이터 링크계층, 네트워크 계층, 전송계층, 세션계층, 표현계층, 그리고 응용계층이 있습니다. 


<br>
<br>


## 운영체제 (OS)  

### 🐬 메모리 구조 

![image](https://user-images.githubusercontent.com/72599761/204128815-90e34819-9fca-4a85-983d-2acbe0abe894.png)


메모리 공간은 **코드, 데이터, 힙, 스택** 총 4종류가 있습니다. 

**코드**는 소스코드가 들어가는 부분이고
**데이터**는 전역변수, 정적변수가 할당되는 부분이에요
**힙**은 사용자가 직접 관리하는 영역으로 데이터가 동적으로 할당되는 공간이구요
**스택**은 함수의 호출정보, 지역변수, 매개변수들이 저장되게 됩니다. 


<br>
<br>


### 🐬 프로세스와 스레드의 차이 

- 프로그램
  - 어떤 작업을 위해 실행할 수 있는 파일 

- 프로세스 

![image](https://user-images.githubusercontent.com/72599761/204128832-935313c7-73d0-4669-809a-e411f78578be.png)


  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램 
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)
  - 동적인 개념으로는 실행된 프로그램을 의미 
  - 프로세스는 각각 독립된 메모리 영역 (code, data, stack, heap의 구조)을 할당받는다. 
  - 기본적으로 프로세스당 최소 1개의 스레드 (메인 스레드)를 갖고 있다. 

- 스레드 

  ![image](https://user-images.githubusercontent.com/72599761/204128857-fe739c11-6662-464c-be5f-9ad407a31a50.png)

  - 프로세스 내에서 실행되는 여러 흐름의 단위 
  - 프로세스의 특정한 수행경로 
  - 프로세스가 할당받은 자원을 이용하는 실행의 단위 
  - 스레드는 프로세스 내에서 각각 stack만 따로 할당 받고, code, data, heap 영역은 공유한다. 
  - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다. 

<br>
<br>

### 🐬 멀티 프로세스와 멀티 스레드의 차이 

- 멀티 프로세스 
  - 하나의 응용프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하는 것이다. 
- 멀티 스레드 
  - 하나의 응용 프로그램을 여러개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다. 
  - 윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만, 멀티 스레딩을 기본으로 하고 있다. 
  - 웹 서버는 대표적인 멀티 스레드 응용 프로그램이다. 

- 멀티 프로세스 대신 멀티 스레드를 사용하는 이유? 
  - 프로그램을 여러개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이다. 
    1. 자원의 효율성 증대 -> 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어든다. 
    2. 처리 비용 감소 및 응답시간 단축 -> 프로세스간의 통신보다 스레드 간의 통신 비용이 적고, 스레드간의 전환속도가 더 빠르다. 

![image](https://user-images.githubusercontent.com/72599761/204128882-475cccfe-06aa-4e00-984f-011001031ee9.png)

<br>

- 참고 

https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

<br>
<br>


## 디자인 패턴 


### 🐬 아토믹 디자인 패턴에 대해 아는가?

- 가장 작은 컴포넌트 단위를 원자로 설정하고 이를 바탕으로 상위 컴포넌트를 만들어 코드 재사용을 최대화하는 방법론
- 원자 -> 분자 -> 유기체 -> 템플릿 -> 페이지


<br>
<br>


## 자료구조 

###  🐬 Array vs LinkedList

- Array 의 element 들은, 인접한 memory 위치에 저장 / Memory 는 Array 가 선언되자 마자 Compile time 에 할당
- LinkedList 의 element 들은, memory 어딘가에 저장 / Memory 는 새로운 node 가 추가될 때 runtime 에 할당
- 데이터 접근이 주 업무일 경우 → Array / 데이터 수정이 주 업무일 경우 → Linked List


<br>
<br>




## 배포 

### 🐬 CloudFront를 사용해본적이 있나요? 사용해봤다면, CloudFront로 배포하는 이유를 설명해주세요.

CloudFront는 AWS에서 제공하는 CDN 서비스 입니다. 멍냥마켓이라는 프로젝트를 진행할 대 유저의 현재 위치를 받아오기 위해서는 HTTPS를 사용해야만 했습니다. S3는 HTTP만 지원이 되는 반면에 cloud front는SSL인증서를 발급받으면 HTTPS로 리다이렉트가 가능하다는 장점이 있었습니다. 그리고 CDN을 통한 페이지 응답 속도가 빠르기 때문에 사용하게 되었습니다.



#### ✨12-1. 클라우드 프론트란? 

- 클라우드 프론트는 짧은 지연시간과 빠른 전송 속도로 데이터, 동영상, 애플리케이션 및 API를 전세계 고객에게 안전하게 전송하는 고속 콘텐츠 전송 네트워크 (CDN) 서비스이다.

- 컨텐츠를 제공하는 서버와 실제 요청 지점 간의 지리적 거리가 매우 먼 경우 or 통신 환경이 안 좋은 경우 
- 요청 지점의 CDN을 통해 빠르게 콘텐츠 제공이 가능하다. 
- cloud front 서비스는 엣지 로케이션을 통해 콘텐츠를 제공한다. 
- 엣지 로케이션 : 컨텐츠가 캐싱되고 유저에게 제공되는 지점.  
	
<br>
<br>
