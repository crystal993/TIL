# Interview 



## Frontend 

### 🐬 CSR(Client Side Rendering)과 SSR(Server Side Rendering)

#### >> SPA와 MPA 

 - SPA (Single Page Application)

   하나의 HTML 파일을 기반으로 자바스크립트를 이용해 동적으로 화면의 컨텐츠를 바꾸는 방식의 웹 어플리케이션이다. 

- MPA (Multiple Page Application)

  사용자가 페이지를 요청할 때마다, 웹 서버가 요청한 UI와 필요한 데이터를 HTML로 파싱해서 보여주는 방식의 웹 어플리케이션이다. 
  전통적인 방식을 이용한다면, SPA가 사용하는 렌더링 방식은 CSR이고, MPA가 사용하는 렌더링 방식은 SSR이다. 



- CSR 

  CSR에선 브라우저가 어플리케이션 구동에 필요한 HTML, JS, CSS 파일 등을 모두 다운로드 한 뒤에 클라이언트 브라우저에서 렌더링을  진행하면서 HTML을 완성하면서 뷰를 구성한다. 

  - 장점
    -  첫 로딩만 기다리면, 동적으로 빠르게 렌더링이 되기 때문에 사용자 경험(UX)이 좋다. 
  - 단점
    - 모든 스크립트 파일이 로드될 때까지 기다려야 한다. 
      - 리소스를 청크 단위로 묶어서 요청할 때만 다운 받게 하는 방식으로 완화시킬 수 있지만 완벽히 해결할 수는 없다. 
    - HTML 바디가 텅텅 비어있어서 검색엔진의 검색 봇이 크롤링을 하는데 어려움을 겪기 때문에 검색엔진 최적화(Search Engine Optimization)의 문제가 있다. 
      - 구글 봇의 경우는 JS를 지원하지만, 다른 검색엔진의 경우 그렇지 않기 때문에 문제가 된다. 

- SSR 

  SSR에선 브라우저가 페이지를 요청할 때마다 해당 페이지에 관련된 HTML, CSS, JS 파일 및 데이터를 받아와서 렌더링을 시킨다. 

  - 장점 
    - 초기 로딩 속도가 빠르기 때문에 사용자가 컨텐츠를 빨리 볼 수 있다. 
    - JS를 이용한 렌더링이 아니기 때문에 검색엔진 최적화가 가능하다. 

  - 단점 
    - 매번 페이지를 요청할 때마다 새로고침 되기 때문에 사용자 경험이 SPA에 비해서 좋지 않다. 
    - 서버에 매번 요청을 하기 때문에 서버의 부하가 커진다. 

<br>
<br>


### 🐬 브라우저 렌더링의 과정은? 

브라우저가 화면에 나타나는 요소를 렌더링 할 때, 웹킷(Webkit)이나 게코(Gecko) 등과 같은 **렌더링 엔진** 을 사용한다. 렌더링 엔진이 HTML, CSS, Javascript로 렌더링할 때 **CRP(Critical Rendering Path)** 라는 프로세스를 사용하며 다음 단계들로 이루어진다.

1. **HTML 파싱(해석) 후, DOM(Document Object Model) 트리 구축**
2. **CSS 파싱(해석) 후, CSSOM(CSS Object Model) 트리 구축**
3. Javascript 실행
   - 주의! HTML 중간에 스크립트가 있다면 HTML 파싱이 중단된다.
4. DOM과 CSSOM을 합쳐서 렌더트리(Render Tree) 구축
   - 주의! `display: none` 속성과 같이 화면에서 보이지도 않고 공간을 차지하지 않는 것은 렌더트리로 구축되지 않는다.
5. **뷰포트 내에서 렌더트리의 각 노드가 가지는 정확한 위치와 크기 계산 (Layout/Reflow 단계)**
6. **계산한 위치/크기를 기반으로 화면에 그림 (Paint 단계)**



**1.불러오기(Loading)**

HTTP 모듈 또는 파일 시스템으로 전달 받은 리소스 스트림을 읽는 과정으로 로더가 이 역할을 맡고 있다. 로더는 단순히 읽는 것이 아니라, 이미 데이터를 읽었는지도 확인하고, 팝업창을 열지 말지, 또는 파일 다운로드 받을지를 결정한다.

 

**2.다운받은 HTML, CSS를 Object Model로 만든다.**

**DOM**(Document Object Model) 이란?

HTML태그를 JS에서 이용할수 있는 객체로 만드는 것이다. 즉 HTML문서의 객체 기반 표현 방식이다.

◾ HTML -> DOM

HTML파일은 HTML파서에 의해 파싱 되어 DOM트리로 변환된다.

![image](https://user-images.githubusercontent.com/72599761/204128531-f1c06a29-3f6e-4435-87ce-af0020315032.png)


◾ CSS -> CSSOM (<link> ,<style> 를 통하여 생성)

CSS파일은 CSS파서에 의해 파싱 되어 CSSOM트리로 변환된다.

![image](https://user-images.githubusercontent.com/72599761/204128544-ecca39dc-1653-4d3b-a9a4-32d7d9651729.png)


**파싱(parse or parsing)?**

문서를 파싱한다는 것은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것이다.

파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리 또는 문법 트리 라고 부른다.

 

**3. DOM과 CSSOM을 합친다.**

◾Render Tree

![image](https://user-images.githubusercontent.com/72599761/204128547-bda612db-e097-4415-8706-4e78ba796f79.png)


**4. Layout**

렌더트리가 만들어 졌으면 이것을 토대로 그려질 노드와 그의 스타일값 그리고 치수까지 계산한다.

- Viewport : 그래픽이 표시되는 브라우저 영역, 크기. 뷰포트는 모바일의 경우 디스플레이의 크기, pc의 경우 브라우저 창의 크기에 따라 달라진다.

 

**5. Paint**

이 정보들을 페인팅 단계로 전달해서 렌더트리의 각 노드를 화면상의 실제 픽셀로 변환한다.


<br>
<br>


### 🐬 BOM과 DOM 

- BOM(Browser Object Model)

  브라우저의 창이나 프레임을 프로그래밍적으로 제어할 수 있게 해주는 객체 모델이다. 이를 통해서 브라우저의 새 창을 열거나 다른 문서로 이동하는 등의 기능을 실행시킬 수 있다. 전역 객체 window가 있으며 하위 객체들로 location, navigator, document, screen, history가 포함되어 있다.  

![image](https://user-images.githubusercontent.com/72599761/204128559-73ab0c21-1967-4a16-93bd-99ae173993ba.png)




- DOM(Document Object Model)

  웹페이지를 프로그래밍적으로 제어할 수 있게 해주는 객체모델이다. 최상위 인터페이스로 node가 있으며 이는 아래와 같은 구조로 나타난다. 


<br>
<br>

### 🐬 타입스크립트란?

#### 💡 개념 

자바스크립트에 타입을 부여한 정적 타입 언어이다. 

<br>

#### 💡 작동 원리 

타입스크립트를 브라우저에서 실행하려면 파일을 변환하는 컴파일 과정을 거쳐서 사용한다. 예를 들어 JAVA를 컴파일하면 Bytecode가 출력되고, C++를 컴파일하면 C가 출력되고, Typescript를 컴파일하면 Javascript가 출력된다. 

<br>

#### 💡 배경

- 자바스크립트의 경우는 동적 타입 언어(dynamic type language)이기 때문에 런타임 속도가 빠르고 유연성이 높지만 신뢰성(타입 안정성)이 떨어진다. 
  - 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되기도 한다. 
  - js를 실행하는 도중에 변수에 예상치 못한 타입이 들어와 타입에러 발생 

- 타입스크립트는 자바스크립트의 이러한 단점을 보완하기 위해서 만들어 짐 
- 타입스크립트는 정적 타입 언어(static type language)이기 때문에 컴파일 시 시간이 조금 걸리더라도 안정성을 보장한다는 점이 장점

<br>

#### 💡 정적 타입 언어 vs 동적 타입 언어

- 정적 타입 언어 : 런타임 이전에 타입이 올바른지 검사를 시행 
- 동적 타입 언어 : 런타임에는 프로그램의 타입이 올바른지에 대한 검사를 시행
  - 만약 레퍼런스 오류를 유발하는 코드가 존재한다면 정적 언어는 컴파일 하는 과정에서 오류를 출력하는 반면, 동적 언어는 해당 구문이 실행되는 시점에서 오류를 출력한다. 

<br>
<br>

### 🐬 SEO란?

- SEO(검색 엔진 최적화)는 웹사이트가 검색 결과에 더 잘 보이도록 최적화하는 과정
  - 검색 엔진은 웹을 크롤링 (en-US)하면서 페이지에서 페이지로 링크를 따라가고, 찾은 콘텐츠의 색인(검색 결과에 보이는 것)을 생성
  - 크롤러는 일정 규칙을 따르므로, SEO를 진행하며 해당 규칙을 밀접하게 따라가면 웹사이트가 검색 결과의 보다 높은 곳에 노출돼 (전자상거래와 광고라면) 수익으로 연결될 수도 있음

<br>
<br>

### 🐬 모듈(module)이란?

모듈이란 **여러 기능들에 관한 코드가 모여있는 하나의 파일** 로 다음과 같은 것들을 위해 사용한다.

- **유지보수성** : 기능들이 모듈화가 잘 되어있다면, 의존성을 그만큼 줄일 수 있기 때문에 어떤 기능을 개선한다거나 수정할 때 훨씬 편하게 할 수 있다.
- **네임스페이스화** : 자바스크립트에서 전역변수는 전역공간을 가지기 때문에 코드의 양이 많아질수록 겹치는 네임스페이스가 많아질 수 있다. 그러나 모듈로 분리하면 모듈만의 네임스페이스를 갖기 때문에 그 문제가 해결된다.
- **재사용성** : 똑같은 코드를 반복하지 않고 모듈로 분리시켜서 필요할 때마다 사용할 수 있다.

<br>
<br>

### 🐬 모듈 번들러란?

현대의 프론트엔드 개발은 모듈단위로 파일을 엮어서 개발하는 방식이다. 즉, 모듈은 서로 의존성을 띄고 있는데 이런 점에서 다음과 같은 문제들이 생긴다.

- 수많은 모듈들의 순서를 어떻게 처리할 것인가? (의존성 처리)
- 모듈이 많아질수록 HTTP 요청이 많아질텐데 이로 인한 오버헤드는 어떻게 해결할 것인가?
- ES6+ 스펙의 코드를 어떻게 처리할 것인가?

위 문제들을 해결하기 위해 등장한 것이 **모듈 번들러(Module Bundler)로 각각의 모듈 의존성을 해결하여 하나의 자바스크립트 파일로 만드는 도구** 이다. 이미지 압축, 최소화(Minification) 등의 여러가지 기능들도 제공하며 유명한 번들러로는 Webpack, Parcel, Rollup 등이 있다.



<br>
<br>

### 🐬 트랜스파일러란? 

트랜스파일링이란 특정 언어로 작성된 코드를 비슷한 다른 언어로 변환시키는 행위를 말하며 이를 해주는 것을 트랜스파일러라고 한다. 트랜스파일러가 필요한 이유는 모든 브라우저가 ES6+의 기능을 제공하지 않기 때문에 이를 ES5코드로 변환시키는 과정이 필요하다. 트랜스 파일러는 이 작업을 수행해준다. 



사실 ES6+의 기능 뿐만 아니라 리액트의 JSX를 자바스크립트 코드로 변환시킨다거나 타입스크립트를 자바스크립트로 변환시키는 등의 역할도 트랜스파일러의 기능 중 하나이다. ES6+나 JSX를 변환시키는 트랜스파일러로는 바벨(Babel)이 있으며, 타입스크립트를 변환시키는 도구로는 타입스크립트 트랜스파일러가 있다.  



보통 프론트엔드 프레임워크 및 라이브러리를 사용해서 개발할 때 모듈 번들러에 트랜스파일러를 추가해서 사용하는 방식을 사용한다. 




## React

### 🐬 리액트란? 

리액트는 UI 자바스크립트 라이브러리로서 싱글 페이지 어플리케이션의 UI를 생성하는 데 집중한 라이브러리입니다. 리액트는 자바스크립트에 HTML을 포함하는 JSX 문법과 단방향 데이터 바인딩을 사용하고 있습니다. 그리고 가상돔이라는 개념을 사용하여 웹 애플리케이션의 성능을 향상시키고, 클라이언트 사이드 렌더링이 가능합니다.



- 개념: UI를 구축하기 위한 자바스크립트 프론트엔드 라이브러리

  사용자와 웹사이트의 상호작용을 돕는 사용자 인터페이스(UI)를 만들기 위한 자바스크립트 라이브러리 

- 장점:

  - virtual DOM을 사용해서 어플리케이션의 성능을 향상시킴

  - 서버, 클라이언트 사이드 렌더링 지원이 가능함

  - 컴포넌트의 가독성이 높고 간단하여 유지보수가 쉬움

  - 다른 프레임워크와도 혼용이 가능



<br>
<br>

### 🐬 컴포넌트란?

레고블럭과 같이 작은 단위로 만들어서 그것을 조립하는 것처럼 개발하는 방법입니다. 컴포넌트를 사용한다면 캡슐화, 확장성, 결합성, 재사용성과 같은 이점이 있습니다. 

<br>
<br>

### 🐬 Props란?

컴포넌트에 어떤 데이터를 전달하고, 전달된 데이터에 따라 다른 모습의 엘리먼트를 화면에 렌더링 하고 싶을 때 해당 데이터를 props에 넣어서 전달하는 것이다. 

<br>
<br>

### 🐬 리액트 엘리먼트 VS 돔 엘리먼트

- 엘리먼트 : 어떤 물체를 구성하는 성분

- 돔 엘리먼트 : 실제 돔에 존재하는 엘리먼트 
- 리액트 엘리먼트 :  가상 돔에 존재하는 리액트 앱을 구성하는 가장 작은 블록들 
  - 포넌트 유형과 속성 및 모든 자식에 대한 정보를 포함하고 있는 자바스크립트 객체 형태로 존재 

<br>
<br>

### 🐬 React, 왜 사용하시나요? 

- SPA 
- React native 앱 개발이 가능 
- 수많은 커뮤니티가 존재 
- 컴포넌트 재사용 가능 (유지보수 용이)

<br>
<br>

### 🐬 리액트의 특징 

#### 1. 가상돔 (웹 애플리케이션의 성능을 극대화 )

- 리액트는 리플로우와 리페인트가 자주 수행되는 문제를 해결하기 위해 화면에 표시되는 DOM과 동일한 DOM을 메모리상에 만들고 DOM 조작이 발생하면 메모리상에 생성한 가상 돔에 모든 연산을 수행한 후, 실제 DOM을 갱신하여 리플로우/리페인트의 연산을 최소화했습니다. 

#### 2. 단방향 데이터 바인딩 

- 단방향 데이터 바인딩은 단 하나의 watcher가 자바스크립트의 데이터 갱신을 감지하여 사용자의 UI 데이터를 갱신합니다. 사용자가 UI를 통해 자바스크립트의 데이터를 갱신할 때는, 이벤트를 통해 갱신하게 됩니다. 이처럼 단방향 데이터 바인딩은 하나의 Watcher를 사용하기 때문에 양방향 데이터 바인딩이 가지는 성능적인 이슈를 해결하고 더 확실하게 데이터를 추적할 수 있게 해줍니다. (양방향 데이터 바인딩은 하나의 데이터 동기화에 두 개의 Watcher가 사용되고, 데이터가 많아지게 되면 이 데이터의 동기화를 위한 수많은 Watcher가 생성되므로 반대로 성능 저하가 발생할 수 있다. )

#### 3. JSX 

- JSX는 자바스크립트와 HTML을 동시에 사용하며, HTML에 자바스크립트의 변수들을 바로 사용할 수 있는 일종의 템플릿 언어 (Template language)입니다. 



#### 4. 선언형 프로그래밍 

- 프로그래밍에는 명령형 프로그래밍과 선언형 프로그래밍으로 구별할 수 있습니다. 명령형 프로그래밍은 프로그래밍을 할 때 어떻게(How)에 집중하는 것을 말하며 선언형 프로그래밍은 무엇(What)에 집중하여 프로그래밍을 하는 것을 말합니다. 



#### 5. 컴포넌트 기반 

- 컴포넌트는 재사용을 할 수 있으며 이런 재사용을 통해 개발 생산성을 향상시킬 수 있습니다. 또한 이렇게 작고 고립된 컴포넌트는 테스트 하기 쉬워 코드를 유지보수하는 데도 크게 도움이 됩니다. 

<br>
<br>

### 🐬 리액트의 내부 작동 원리를 재조정(Reconciliation) 개념과 함께 설명하세요. 

React에서 DOM을 어떻게 렌더링하고 브라우저 이벤트를 처리하나요? 
실제로 DOM을 제어하지 않고, 중간에 virtual DOM을 두어 virtual DOM이 변경될 때, 실제 DOM을 변경하도록 설계되어 있습니다. 이 작업을 Reconciliation이라고 합니다.  virtual DOM을 갱신하는 방법에는 setState()메소드를 호출하는 방법과 redux의 경우처럼 store가 변하면 다시 최상위 컴포넌트의 render()함수를 호출해서 갱신하는 2가지 방법이 있습니다.

<br>
<br>

### 🐬 리액트에 있는 라이프사이클과 각 라이프사이클의 역할을 설명하세요. 

리액트의 라이프사이클은 크게 4가지로 설명할 수 있습니다. 최초로 컴포넌트 객체가 생성될 때 한 번 수행되어지는 componentDidMount()와 초기에 화면을 그려줄 때와, 업데이트가 될 때 호출되는 render()가 있습니다. 그리고 컴포넌트의 속성 값 또는 상태값이 변경되면 호출되어지는 componentDidUpdate()와 마지막으로 컴포넌트가 소멸될 때 호출되어지는 componentWillUnmount()가 라이프사이클의 역할입니다.

<br>
<br>

### 🐬 리액트 Hooks의 장점은 무엇인가요? 

Hooks의 장점은 로직의 재사용이 가능하고 관리가 쉽다는 것입니다. 함수안에서 다른 함수를 호출하는 것으로 새로운 hook을 만들어볼 수 있습니다. 기존의 class component는 여러단계의 상속으로 인해 전반적으로 복잡성과 오류 가능성을 증가시켰습니다. 하지만 function component에 hooks에 도입되면서 class component가 가지고 있는 기능을 모두 사용할 수 있음은 물론이고 기존 class component 복잡성, 재사용성의 단점들까지 해결됩니다. 



<br>
<br>

### 🐬 Class Component와 Function Component의 차이점에 대해서 설명하세요. 

Class Component는 여러 단계의 상속으로 이루어져 있습니다. 그리하여 복잡성과 오류 가능성을 증가 시켰습니다. 이로 인해 Function Component가 탄생하게 되었고, class component는 라이프 사이클을 가지며 이로인해 각각 생명주기 메소드에 대해 알고 있어야 합니다. 하지만 function component는 이러한 기능을 hook을 사용하여 생명주기에 원하는 동작을 하게 합니다.



<br>
<br>

### 🐬 React의 리렌더링 조건은? 

4가지가 있습니다. 

- 상태(state)값이 변경될 때
- 부모 컴포넌트가 리렌더링될 때
- 자신이 전달받은 props값이 변경될 때
- 강제 업데이트(forceUpdate)함수

<br>
<br>

### 🐬 React 에서 상태 변화가 생겼을 때, 변화를 어떻게 알아채는지에 대해서 설명하세요.

React는 상태를 불변성을 띄게 변경합니다. 그로 인해 배열이나 객체의 주소값이 변경되면 변화가 되었다는 것을 알 수 있습니다. 

- 리액트는 상태값을 업데이트할 때 얕은 비교를 수행한다. 
- 객체의 속성 하나하나를 비교하는 게 아니라 참조값만 비교하여 상태변화를 감지한다. 
- 값이 아무리 변화하더라도 참조값은 그대로이므로 ...(스프레드 연산자)를 사용해서 새로운 참조값을 만들어서 사용한다. 
- 이러한 이유로 배열이나 객체를 업데이트할 때 ...(스프레드 연산자)를 사용해서 배열이나 객체를 새로 생성해서 새로운 참조값을 만들어서 상태를 업데이트 한다. => 불변성을 지켜준다. 

<br>
<br>

### 🐬 React 에서의 불변성

#### 💡 정리

- **불변성**이란 **메모리 영역의 값을 변경할 수 없는 것**이다.
- 리액트는 **불변성**을 지켜줌으로써 **효율적인 상태 업데이트**를 한다.
- 리액트는 불변성을 지켜줌으로써 사이드 이펙트를 사전 방지하고 프로그래밍의 구조를 단순하게 유지한다.
- 불변성을 가진 원시타입과 달리 참조타입의 경우에는 의도적으로 불변성을 지켜주어야한다. 이 때 새로운 주소 값을 가진 객체를 생성하여 상태를 업데이트 해준다. spread operator, map, filter, slice, reduce 메소드들을 활용한다.

<br>

#### 💡 불변성이란? 

- 불변성은 값의 변화를 의미하는 것이 아니다. 

- 불변성의 진짜 의미는 **메모리 영역에서 값을 변경할 수 없다는 의미**이다. 

<br>

#### 💡 React에서 불변성을 왜 지켜야할까? 

리액트에서 불변성을 지켜주는 이유는 리액트가 상태 업데이트를 하는 원리 때문입니다. 

React는 상태를 불변성을 띄게 변경합니다. 그로 인해 상태 객체의 주소값이 변경되면 변화가 되었다는 것을 알 수 있습니다. 

- 효율적인 상태 업데이트 (얕은 비교 수행)

  => 상태업데이트 원리는 위의 질문에 대한 답에 있음. 

  : 얕은 비교란 객체의 속성을 하나하나 다 비교하지 않고, 객체의 참조 주소값만 변경되었는지 확인합니다. 얕은 비교는 계산 리소스를 줄여주기 때문에 리액트는 효율적으로 상태를 업데이트 할 수 있습니다. 

- 사이드 이펙트 방지 및 프로그래밍 구조의 단순성 

  : 원시타입은 애시당초 불변성 특징을 가지고 있지만, 참조 타입인 객체나 배열의 경우 새로운 값을 변경할 때 원본 데이터가 변경됩니다. (불변성이 지켜지지 않습니다.) 이렇게 원본 데이터가 변경될 경우, 이 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류가 발생할 수 있습니다. 프로그램 복잡도가 올라갑니다. 

<br>

#### 💡 React에서 불변성을 지키는 방법 

- spread operator, map, filter, slice, reduce, concat 등등 새로운 배열을 반환하는 메소드들을 활용하면 된다. 
- 참조타입의 경우에는 새로운 주소값을 가진 객체를 생성하여 상태를 업데이트 해준다. 

<br>
<br>

### 🐬 상태 관리를 왜 할까요? 그리고 평소에 state 관리는 어떻게 하시나요? 

상태관리란  웹 어플리케이션을 render하는데 있어 영향을 미칠 수 있는 값을 관리하는 것을 의미합니다.

상태관리를 하는 이유는 2가지가 있습니다. 

첫번째는 상태관리는 UI에 직/간접적으로 영향을 주게 됩니다. 따라서 상태를 제대로 관리하지 못하면 유저에게 어색한 경험을 제공하거나 버그가 생기게 됩니다. 

두번째는 리액트는 단방향 데이터 바인딩을 하므로 부모에서 자식 컴포넌트로만 데이터 전달이 가능합니다. props drilling이 심할 때나 여러 컴포넌트에서 접근해서 사용하는 상태 값을 가질 경우에 유지보수가 어려워지고, 이를 해결하기 위해 상태관리가 필요합니다. 

평소에 모달창을 열고 닫는 상태값처럼 한 컴포넌트 내에서 상태값 관리가 가능하면 useState로 상태관리를 하고, 단순 props drilling이 심할 때나 적당히 복잡한 컴포넌트가 존재하고, 외부 라이브러리를 쓰고 싶지 않을 때는 context와 useReducer 조합을 사용합니다. 특정 구성 요소만 re-render 시키거나, 사이드 이펙트를 줄이기 위해서  redux toolkit을 사용하여 관리합니다. 

<br>

- 상태란? 웹 어플리케이션을 render하는데 있어 영향을 미칠 수 있는 값이다.

- 상태관리란? 웹 어플리케이션을 render하는데 있어 영향을 미칠 수 있는 값을 관리하는 것을 의미

- 상태의 종류? 전역 상태, 컴포넌트 간의 상태, 지역 상태 

- 상태관리는 왜 필요할까? 

  1. UI에 직/간접적으로 영향을 주기 때문에 => 유저에게 어색한 경험, 버그 발생 

  2.  리액트는 단방향 데이터 바인딩을 하므로 부모에서 자식컴포넌트로만 데이터 전달이 가능하다. props drilling이 심할 때나 여러 컴포넌트에서 접근해서 사용하는 상태값을 가질 경우에 유지보수가 어려워진다. 이를 해결하기 위해 상태관리가 필요하다. 

<br>

- 나의 상태관리 

  1. useState 

     : 모달창을 열고 닫는 상태값처럼 한 컴포넌트 내에서 상태값 관리가 가능할 때 사용

  2. context와 useReducer 조합 

     : 단순 props drilling이 심할 때나 적당히 복잡한 컴포넌트가 존재할 때, 낮은 빈도의 업데이트와 같은 정적인 상태의 전달, 외부 라이브러리를 쓰고 싶지 않을 때 사용 

  3. redux-toolkit 

     : 2번보다 강력한 기능이 필요할 때! props drilling도 심하고 굉장히 복잡한 컴포넌트 구조이거나 저장소 상태의 특정 부분만 사용하고, 해당 값을 re-render 시키거나, 사이드 이펙트를 줄이기 위해서 사용. 

<br>     

(useReducer는 context내부에 포함된 컴포넌트들이 상태값의 일부에만 관심있더라도 강제로 re-render되므로 성능문제 발생. useReducer는 미들웨어도 존재하지 않는다. )


<br>
<br>


#### 💡 1-1. props drilling이란? 

리액트는 대표적으로 단방향 데이터흐름 이라는 특징이 있습니다. 이는 data를 전달 할 때 부모 컴포넌트에서 자식 컴포넌트로만 데이터 전달이 가능합니다. 예를 들어 부모컴포넌트에서 props를 통해 최하위 자식컴포넌트로 데이터를 전달해야할 때, 중간 컴포넌트는 그 데이터가 필요하지 않음에도 불구하고 props를 전달하는 과정을 props drilling이라고 합니다. 

- Props drilling으로 발생하는 문제점

  - 여러개의 컴포넌트를 타고 내려가다 보면 props의 지옥이 펼쳐지고 이 props가 도대체 어디서부터 시작된건지 타고 올라가는 것이 쉽지 않습니다. 이 때문에 유지 보수 또한 어려워진다. 

  - ⭐ props를 통해 여러번 전달되는 데이터가 전달되는 경우 실제 변화가 적용되어야 하는 컴포넌트 뿐만 아니라 전달 경로에 있는 컴포넌트들도 리렌더하는 문제가 발생합니다.


<br>
<br>


#### 💡 1-2. Context API와 Redux의 차이 

- context + useReducer는 context를 통해 현재 상태값을 전달하는데 의존한다. Redux는 Context를 통해 현재 Redux 스토어 인스턴스를 전달한다. 
- useReducer는 context내부에 포함된 컴포넌트들이 상태값의 일부에만 관심있더라도 강제로 re-render되므로 성능문제 발생. useReducer는 미들웨어도 존재하지 않는다. 
- Redux를 사용하면 저장소 상태의 특정 부분만 사용하고 해당 값이 변경될 때만 re-render 한다. 

- Context, useReducer는 React에 내장되어 있는 기능이므로 외부에서는 사용이 불가능하지만 Redux는 vue, angular 등 외부에서도 사용이 가능하다. 
- Context API + useReducer는 낮은 규모와 빈도의 업데이트와 같은 정적인 상태의 전달에는 괜찮지만, Flux와 유사한 상태 전파의 대체물로는 부족하다. 
- Context API - redux의 useSelector, styled-components의 themeProvider 등 

<br>
<br>

### 🐬 Redux가 무엇인가요, 왜 Redux를 사용하시나요?

리덕스는 전역 상태 관리를 하기 위한 상태관리 라이브러리입니다. 
**컴포넌트들의 데이터 교류가 복잡해질 때** 이를 효율적으로 관리하기 위해 리덕스를 사용합니다. 
리덕스를 사용하면 상태값을 컴포넌트에 종속시키지 않고, 상태 관리를 컴포넌트의 바깥에서 관리할 수 있기 때문에 효율적인 상태관리가 가능해진다. 

<br>

- 컴포넌트들의 데이터 교류가 복잡해질 때  

  1. props drilling이 심할 때

  2. 여러 컴포넌트에서 접근해서 사용해야하는 상태값을 가질 경우

<br>
<br>

### 🐬 Redux 말고 다른 전역 상태관리 아는 것 하나와 차이점을 말해주세요. 

- Redux는 Flux 아키텍처 기반(데이터 흐름이 단방향 )
- Recoil은 Atomic 모델 기반(Atom이라는 작은 상태 단위로 관리하고 Atom을 결합하여 데이터를 가공한다.)


<br>
<br>


#### 💡 3-1. Flux 아키텍처란?

- MVC 모델의 한계로 인해 생김 

- flux 아키텍처의 데이터 흐름은 단방향이다.  

- 데이터의 흐름은 dispatcher => store => view 순서이며 뷰에서 입력이 발생하면 action을 통해서 dispatcher로 향하게 된다. 

![image](https://user-images.githubusercontent.com/72599761/204128681-99ddf4e5-fdb2-4910-98af-b40d925cb471.png)

##### - Dispatcher 

dispatcher는 Flux 애플리케이션의 모든 데이터 흐름을 관리하는 일종의 허브 역할을 한다. 
액션이 발생하면 디스패처로 메세지나 액션 객체가 전달이 되고, 디스패쳐에서는 이러한 메세지 혹은 액션 객체를 콜백함수를 통해 스토어로 전달한다. 스토어에 접근하기 위한 일종의 단계이고, 액션을 통해 접근하기 위해서는 디스패처의 단계를 거쳐야한다. 

<br>

##### - Action 

디스패처를 통해 스토어에 변화를 일으킬 수 있는데 이 때 디스패처의 데이터 묶음을 액션이라고 한다. 

<br>

##### - Store

스토어는 애플리케이션의 상태를 저장 합니다. 모든 상태 변경은 스토어에 의해 결정되며 상태 변경을 위한 요청을 스토어에 직접 할 수는 없습니다. 상태 변경을 위해서는 꼭 액션 생성자를 통해 디스패쳐 단계를 거친 후 액션을 보내야만 상태값 변경이 가능합니다.


<br>
<br>
	

### 🐬 MVC 모델이란? 

![image](https://user-images.githubusercontent.com/72599761/204128699-43124b80-a454-40b1-95ad-2ff69728e64f.png)

- controller, model, view로 이루어진 아키텍처 
- Controller는 Model의 데이터를 조회하거나 업데이트하는 역할을 하고, Model은 이런 데이터를 View에 반영시킨다. 또 View는 사용자로부터 데이터를 입력받기도 하므로 사용자의 입력이 Model에 영향을 주기도 한다. 
- 이러한 구조가 거대한 어플리케이션을 대상으로 한 프로젝트에 대해서는 복잡하고 빨라진다. 

![image](https://user-images.githubusercontent.com/72599761/204128708-039cf642-8ce1-488f-a7c3-03085b3f18e4.png)

<br>

- 문제점 : 사용자와의 상호작용이 view에서 일어났기 때문에 model을 업데이트 해줘야하고, 의존하는 model이 있을 경우 그 model까지 업데이트를 해줘야 한다. 아주 많은 코드 변경이 발생한다. 

<br>

- 해결 : 단방향 데이터 흐름을 택했다. 단방향 데이터 흐름을 가지는 구조는 데이터는 단방향으로만 흐르고, 새로운 데이터를 넣으면 처음부터 다시 시작되는 방식으로 설계되어있다. 이러한 시스템 구성을 Flux 구조라고 한다. 

<br>
<br>

### 🐬 JSX가 무엇인가요?

JSX는 자바스크립트 코드를 HTML처럼 표현할 수 있는 React 엘리먼트를 생성하는 언어입니다.

<br>
<br>



### 🐬 virtual DOM이 무엇인가요? virtual DOM이 좋은 이유에 대해서 설명해주세요. 

virtual DOM은 실제 DOM의 변화를 최소화시켜주는 역할을 합니다.  virtual DOM을 사용하는 이유는 효율성 때문입니다. virtual DOM을 사용하면 실제 DOM을 바꾸는 것보다 시간복잡도가 낮아집니다. 만약, HTML파일에 20개의 변화가 생기면 과정 역시 20회가 이루어집니다. 하지만 virtual DOM은 변화된 부분만 가려내어 실제 DOM에 전달하기에 실제 DOM은 1회로 인식하여 단 한번의 렌더링 과정만 거치게 됩니다. 


<br>
<br>

### 🐬 virtual DOM과 리얼 돔의 차이를 설명해주세요 

- 리얼돔 : 웹 페이지를 이루는 태그들을 자바스크립트가 이용할 수 있게끔 브라우저가 트리구조로 만든 객체 모델을 의미한다. 

- 가상돔 : 가상 DOM은 DOM의 상태를 메모리 위에 계속 올려두고, DOM에 변경이 있을 경우 해당 변경을 반영한다.

- 변경 전과 변경 후 가상 돔끼리 비교 후 바뀐 부분만 실제 돔에 적용된다. 

  <br>

돔이란 Document Object Model 문서 객체 모델의 약자입니다. 문서객체란 Web browser 안에서 HTML 문서에 Javascript가 접근할 수 있도록 html 태그를 객체로 만든 것입니다. 

여기서 문제점은 돔은 새로운 요청이나 변경사항이 있을 때마다 매번 리렌더링을 합니다. 매번 새롭게 구성하기 때문에 렌더할 양이 많아지면 속도가 느려지게 됩니다. 

<br>

때문에 가상돔이 나왔습니다. 
가상돔은 돔의 구조를 흉내낸 Javascript 객체(트리구조)입니다. 
In-memory에 존재하기 때문에 실제로 렌더되지 않습니다. 

리액트가 가상돔을 반영하는 절차를 보면, 변경사항이 있으면 UI를 가상돔에 리렌더링 합니다. 가상돔끼리 비교하고, 변경된 부분만 실제 돔에 적용시킵니다. 

-  


<br>
<br>
	

### 🐬  useRef에 대해 설명해보세요. 

useRef는 저장공간(변수 관리) 이나 DOM 요소에 접근하기 위해 사용되는 훅입니다. 

state 값을 바꿀 때 대표적으로 사용되는 훅이 useState인데, useRef는 ref 안에 값을 아무리 변경해도 컴포넌트는 다시 렌더링 되지 않습니다. 즉 state 대신 ref를 사용하면 불필요한 렌더링을 막을 수 있습니다. 또한 컴포넌트가 렌더링이 되어도 ref 안에 저장되어 있는 값은 변화되지 않고 그대로 유지가 됩니다. 이에 변경시 렌더링을 발생시키지 말아야 하는 값을 다룰 때 편리합니다. 

<br>

DOM 요소 접근에 대해서는 보통 DOM에 접근해서 focus 하는 곳에 많이 사용한다. querySelector를 사용해서도 DOM 요소를 접근할 수 있지만, React에서 querySelector를 사용하게 되면, 실제 DOM의 요소를 가져오게 된다. 하지만 React는 Virtual DOM을 통해 Real DOM을 그리기 때문에, React가 제어하고 있는 Virtual DOM 안에 있는 요소에 접근할 수 있다. 

<br>

- useRef는 저장공간(변수 관리)이나 DOM 요소에 접근하기 위해 사용되는 훅이다. 
  - 저장공간(변수 관리) : 리렌더링 하지 않고, 컴포넌트의 속성만 조회 & 수정한다. 
  - focus를 선택해주거나 텍스트의 선택 영역, 두개 컴포넌트의 싱크를 맞출 때 DOM을 직접적으로 건드려야할 때 사용한다. 

<br>
<br>


### 🐬  useEffect의 실행 순서에 대해 설명해주세요.

useEffect는 bottom-top 방식으로 동작합니다. return 문이 읽히고 useEffect 훅이 읽힙니다. 
즉 컴포넌트가 렌더링이 된 이후에 useEffect가 실행됩니다. 

- useEffect는 컴포넌트가 렌더링이 된 후에 실행되는 것이다. 
- 가장 하위에 있는 컴포넌트의 useEffect가 먼저 실행된다. 

<br>
<br>


### 🐬  useEffect와 useLayoutEffect 차이에 대해 설명해주세요. 

useEffect는 비동기로 함수가 실행되며, 렌더링이 된 이후에 동작하는 hook입니다. 반면, useLayoutEffect는 동기로 함수가 실행되며, 렌더링 되기 이전에 동작하는 hook입니다. 

dom에서 동기적으로 리렌더링이 일어나면 앞선 작업이 끝나기 전까지 유저는 DOM에서 제대로 보지 못하게 됩니다. 이 때문에 비동기적으로 동작하는 useEffect를 먼저 사용해보는 것을 고려하는게 좋습니다. 
단 동기적인 렌더링이 필요하거나 깜박임 등이 일어나면 useLayoutEffect를 제한적으로 고려해보는게 좋습니다. 

- useEffect는 컴포넌트들이 render와 paint된 후 실행됩니다. 비동기적으로 실행됩니다. 
- useLayoutEffect는 컴포넌트들이 render된 후 실행되며, 그 이후에 paint 됩니다. 이 작업은 동기적으로 실행됩니다. 

<br>
<br>

### 🐬  useEffect 메소드로 componentWillUnmount 가 동작할 수 있는 방법에 대해서 설명하세요.

useEffect 코드 내부에서 return하는 익명함수를 작성하는 방법으로 componentwillUnmount를 구현할 수 있습니다. 

```javascript
useEffect(() => {
    console.log('컴포넌트가 화면에 나타남');
    return () => {
      console.log('컴포넌트가 화면에서 사라짐');
    };
  }, []);
```



- componentwillUnmount는 컴포넌트가 화면에서 사라질 때 나타나는 라이플사이클입니다. 

<br>
<br>

### 🐬 메모이제이션을 하는 이유는? 

- 메모이제이션 : 컴퓨터 프로그램이 동일한 계산을 반복해야할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술 
- 메모이제이션을 하는 이유 
  - 비싼 연산을 반복하는 것을 피하여 성능을 향상 
  - 안정된 값을 제공한다.  

<br>
<br>

### 🐬 웹 성능 향상을 위해 최적화를 해 본 경험이 있나요? 혹은 useMemo와 useCallback 메소드를 활용해 최적화하는 원리에 대해서 설명하세요.

useMemo와 useCallback은 성능 최적화를 위해서 사용되는 Hook입니다. 이때, useMemo는 특정 결과값을 재사용하는 반면에 useCallback은 특정함수를 새로 만들지 않고 재사용하고 싶을 때 사용합니다. 이 둘은 dependency 리스트를 이용하여 그 중 하나가 변경이 되면 결과에 대해 변경됩니다. 

<br>
<br>


### 🐬  데이터 10,000개를 가지고 무한스크롤 구현시에 가장 중요하게 고려해야할 점은? 

- 스크롤을 아주 많이 내려서 많은 이미지들이 DOM에 렌더링 되어있다면 이로 인한 성능 저하가 발생할 수 있다. 
- React-virtualized를 사용하면, 실제 보이는 컴포넌트만 DOM에 렌더링하여 이러한 문제를 해결할 수 있다. 


<br>
<br>

###  🐬 Context API란?

- 컴포넌트를 건너띄고 다른 컴포넌트에서 state, function을 사용할 수 있음

- redux의 많은 어려운 개념보다 context api는 Provider, Consumer, createContext 개념만 알면 적용가능

- context는 컴포넌트안에서 전역적으로 데이터를 공유하도록 나온 개념

  - 로그인 데이터, 웹 내 사용자가 쓰는 설정파일, 테마, 언어 등 다양하게 컴포넌트간 공유되어야할 데이터로 사용

    

<br>
<br>

## HTML

### 🐬 로컬스토리지 vs 세션스토리지 vs 쿠키 

모두 클라리언트 상에서 key/value 쌍을 저장할 수 있는 메커니즘으로 value는 반드시 문자열이어야 한다. 또한 모두 동일 출처 정책(SOP)을 따르기 때문에 다른 도메인에서 접근할 수 없다. 

![image-20221127200537633](C:\Users\ggg71\AppData\Roaming\Typora\typora-user-images\image-20221127200537633.png)

<br>
<br>



### 🐬 일반적으로 CSS 태그를 태그 사이에 위치시키고, JS 태그를 태그가 끝나기 직전에 위치시키는 이유가 무엇인가요?

**사용자에게 보여지는 화면의 속도를 더 빠르게 하기 위해서입니다.**
사용자가 홈페이지를 들어갈 경우 브라우저 렌더링 엔진이 HTML파일을 먼저 읽게 됩니다. 이 때 HTML파일이 파싱하여 DOM이 완성되게 됩니다. 하지만 화면이 만들어지기 위해선 HTML파일을 파싱한 DOM과 CSS파일을 파싱한 CSSOM이 합쳐지고 난 후에 만들어지게 됩니다. 이 때 CSS `<link>`태그를 `<head></head>`에 위치시킨다면 HTML과 CSS가 병렬적으로 렌더링 되어 사용자에게 보여지는 화면의 속도가 빨라지게 됩니다. 또한, JS태그를 `<body>` 태그가 끝나기 직전에 위치시키는 이유는 `<script>` 태그를 만나면 HTML 파싱을 잠시 멈추고, JS에 대한 파일을 다 읽고 난 후에 다시 HTML 파일을 읽기 때문입니다. 이러한 이유로 화면에 그려지는 속도가 느려지기 때문에 맨 뒤에 두는 것이 바람직합니다.

<br>
<br>

### 🐬 시맨틱 태그(sementic tag) 에 대해 설명하세요. 

**시멘틱 태그는 브라우저와 개발자에게 명확하게 설명하는 태그를 의미합니다.** 예를 들어 `<div>`와 `<span>`은 무엇을 담고 있는 컨텐츠인지 그 자체로 설명을 하지 못합니다. 하지만 `<form>`과 `<table>`은 각각 제출할 form과 표를 의미하는 컨텐츠입니다. 이러한 시맨틱 태그는 검색 엔진에 유용하게 활용될 뿐만 아니라 시각장애인을 위해 화면 판독기로 페이지를 탐색할 때 중요한 지표로 활용되어집니다.

<br>
<br>

## DOM

### 🐬 개발자도구를 많이 사용하셨다면 주로 어떤 용도로 사용했나요?

**개발자 도구에는 주로 Performance, Elements, Styles, Console, application, Network 탭이 있습니다.**
여기서 저는 총 4가지의 탭을 주로 사용했습니다. Elements탭과 Styles 탭은 현재 보고 있는 페이지의 HTML과 CSS를 빠르게 변경할 수 있어서 테스트를 자주 이용했었습니다. 그리고 console 탭은 필요한 데이터가 잘 출력되는 지 확인하기 사용하였습니다. 마지막으로 application 탭은 로그인이나 로그아웃 할 때에 저장한 token이 지정한 위치에 잘 저장되는지 확인하기 위해 사용하였습니다.





<br>
<br>

### 🐬 웹팩과 바벨의 역할에 대해서 설명하세요.

**웹팩은 자바스크립트 어플리케이션을 위한 정적 모듈 번들러입니다.** 이 때 모듈 번들러는 여러 개의 파일을 하나로 합쳐주는 것을 의미합니다. 우리는 개발을 할 때 기능에 따라 코드를 나누어서 이해하기 쉽게 작성합니다. 이때 배포할 때는 자바스크립트 파일이 한번에 다운받을 수 있어야하는데 이 역할을 웹팩이 대신해줍니다. **바벨은 자바스크립트 트랜스파일러입니다.** 모든 브라우저가 ES6의 기능을 제공하지 않기 때문에 ES5코드로 변환시키는 과정이 필요하기 때문에 사용되어집니다.

<br>
<br>



### 🐬 event.preventDefault() 의 역할이 무엇인지 설명하세요.

**event.preventDefault는 기본으로 정의된 이벤트를 작동하지 못하게 하는 메소드입니다.** 예를 들어 이름을 입력하는 input의 값이 영문만 가능하다면, 사용자가 숫자또는 한글을 입력했을 때 입력되는 것을 막아야합니다. 이 때 이 기능을 주로 사용합니다.

<br>
<br>



### 🐬 intersection Observer API가 무엇인지 설명하세요.

intersection Observer API는 target과 root의 교차 발생을 비동기적으로 관찰하는 web API입니다. 메인 thread에 영향을 주지 않고, Callback을 실행하기에 매번 layout을 새로 그려 render tree를 새로 만들지 않기 때문에 브라우저의 성능을 향상시킬 수 있습니다. 주로 무한 스크롤을 구현할 때 자주 사용되는 api입니다.

<br>
<br>



### 🐬 이벤트 위임이 무엇인가요?

**이벤트 위임은 상위 노드에서 하위 노드의 이벤트를 제어 하고 싶을때 쓰는 방식입니다.** 예를 들어 todoList앱을 사용자가 이용할 때 오늘의 할일을 추가하고, 그 추가된 항목의 일을 완료했으면, 완료했다는 의미로 밑줄을 그어야할 것 입니다. 이 때 이벤트 위임을 활용하여, li태그의 추가된 리스트를 통제할 수 있는 ul태그에 이벤트 리스너를 연결해서 하위에서 발생하는 클릭 이벤트를 감지시켜주도록 사용되어집니다.

<br>
<br>



### 🐬 이벤트 버블링이란 무엇이며 막을 수 있는 방법은 무엇인가요?

**이벤트 버블링은 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성을 의미합니다.** 이벤트 버블링을 막기 위해서는 이벤트 객체의 메서드인 `event.stopPropagation()`를 사용하면 됩니다.

<br>
<br>



## CSS 

### 🐬 id와 class 셀렉터의 차이점에 대해 설명하세요. 

id는 문서 안의 유일한 요소를 식별하고 싶을 때 사용하며, class는 공통점이 있는 여러 요소들을 그룹화하여 식별하고 싶을 때 사용합니다. CSS에서 id는 #(샵)을 붙이며, class는 .(피리어드)을 붙여서 구별합니다. 또한 id는 class의 속성보다 우선순위가 높으며, id의 속성은 해당 요소에 부여된 class의 속성과 관계없이 작동합니다. 

<br>
<br>

### 🐬 CSS 박스 모델에 대해서 설명하세요.

모든 HTML 요소는 박스 모양으로 구성되기 때문에, 이를 박스 모델이라고 합니다. 박스 모델에서는 각 HTML 요소들에 padding, border, margin, content가 있습니다. content는 박스의 실질적인 내용으로, 텍스트나 이미지 등 요소의 실제 내용이 들어갑니다. padding은 content와 border 사이에 있는 안쪽의 여백입니다. border는 content와 padding을 감싸는 테두리입니다.  마지막으로 margin은 border를 기준으로 이웃하는 요소 사이의 간격입니다.

- content: 박스의 실질적 내용으로, 텍스트나 이미지 등 요소의 실제 내용이 들어간다.
- padding: content와 border 사이에 있는 안쪽 여백이다.
- border: content와 padding을 감싸는 테두리이다.
- margin: border를 기준으로 이웃하는 요소 사이의 간격이다.

<br>
<br>

### 🐬 CSS에서 px, em, rem, vh, vw 단위들의 차이점은 무엇인가요?

#### (1) 절대 길이 단위

- 절대 길이 단위는 물리적인 측정거리를 의미합니다. 
- px은 절대길이 단위로 일반적인 모니터 디스플레이의 1px을 의미합니다. 

<br>

#### (2) 상대 길이 단위

- 상대길이 단위는 다시 **글꼴 상태길이**와 **뷰포트 백분율 길이**로 나뉘게 됩니다. 
- `em`, `rem`같은 **글꼴 상대 길이**는 길이값을 **특정 문자나 현재 사용하는 폰트를 기준으로 설정**합니다. 
  - `em` : `부모 요소`의 폰트 사이즈를 기준으로 한다. 
  - `rem` : `루트 요소`, `<html>`요소의 폰트 사이즈를 기준으로 한다. 
- `vh`, `vw`는 **뷰포트 상대 길이**입니다. 
  - `vh` : 뷰포트의 초기 컨테이너 블록의 높이 1%를 기준
  - `vw` : 뷰포트의 초기 컨테이너 블록의 너비 1%를 기준

<br>
<br>

### 🐬 CSS 레이아웃 기법의 종류와 특징에 대해서 설명하세요. (grid, flexbox)



#### 1. flex box

 flexbox는 인터페이스 내 아이템 간 공간 배분과 정렬 기능을 제공하기 위한 1차원 레이아웃 모델로 설계되었습니다. X축 또는 Y축 방향으로 요소를 배치, 정렬할 수 있어서 각 요소의 순서를 변경할 수 있습니다. 그렇기 때문에 기존 CSS 레이아웃 기술에 비교했을 때 손쉽게 멀티스크린에 대응할 수 있습니다.

####  <br>

#### 2. grid

grid는 테이블처럼 세로 열과 가로 행을 기준으로 요소를 정렬합니다. 그러나 테이블에 비해 grid는 더 다양한 레이아웃을 구현할 수 있습니다. 행과 열 격자 구조에 요소를 자유롭게 배치할 수 있고, HTML 문서 위계 구조와 무관하게, grid 인터페이스 내부에 포함된 자식 아이템을 Grid 내부에 자유롭게 위치시킬 수 있습니다.

<br>
<br>

### 🐬 CSS in JS(styled component)의 장단점에 대해서 설명하세요.

#### - 장점

- class 명이 빌드시 유니크한 해시값으로 변경되기 때문에 기존의 복잡한 class 명명 규칙을 해결해줍니다. 
- 컴포넌트 단위로 추상화되기 때문에 css 파일 간의 의존성을 신경쓰지 않아도 됩니다. 
- 컴포넌트와 css가 동일한 구조로 관리되기 때문에 불필요해진 css를 관리하기 위해서 별도의 리소스를 투입할 필요가 없습니다. 
- css 컴포넌트 스코프에서만 적용되기 때문에 우선순위 문제가 발생하지 않습니다. 

<br>

#### - 단점 

- 번들의 크기가 커진다는 단점이 있습니다. CSS in JS를 사용하기 위해서는 여러 라이브러리를 사용하는데 라이브러리 추가는 곧 번들 사이즈가 증가함을 의미합니다. 
- 번들 사이즈가 커지게 되면 다운로드 시간도 오래 걸리기 때문에 사용자 경험에 치명적이게 됩니다. 
- CSS in JS는 자바스크립트가 모두 로딩된 후 css 코드가 생성되기 때문에 더 느려집니다. 



#### 



<br>
<br>

## Javascript

### 🐬 Javascript 언어의 특징

- 크로스 플랫폼 언어

- 클라이언트 측 및 서버 측에 널리 사용됩니다.

- 컴파일 과정이 따로 필요가 없으며 바로 화면에 적용 가능

- 인터프리터 언어 (클라이언트의 웹 브라우저에 의해 해석되고 실행된다.)

- 객체 기반의 스크립트 언어

- 이벤트 기반의 프로그래밍 언어

- ⭐ 단일 스레드 기반 언어

- ⭐ 느슨한 타입의 동적 언어 -> 타입스크립트로 보완이 가능하다. 

  

#### 장점

1. 웹 브라우저에서 동작하는 스크립트 언어로 운영체제의 제한을 받지 않는다.
2. 컴파일 과정이 없기 때문에 다른 언어와 비교했을 때 빠른 시간 안에 스크립트 코드 작성 가능 (HTML 파일 내에 작성할 수 있으므로 개발 속도 빠름)
3. 웹 서버에 주는 부담이 적다.
4. 러닝 커브가 낮다.

#### 단점

- 브라우저 상에 소스가 노출되어서 보안에 취약

- 브라우저 상에서 소스 변경 가능. 사용자가 임의로 기능을 실행하거나 악용할 가능성이 있다.

- 한정된 객체와 객체 함수 제공

- 다중 프로세서 다중 스레딩 기능이 없다.

- 동적 타입 언어라서 개발자의 의도와 상관없이 암묵적으로 타입이 변환이 될 수 도 있다. 

  => 동적타입 언어는 유연성이 높지만 신뢰성이 떨어진다. 

<br>
<br>

### 🐬 스코프에 대해서 설명하세요.

스코프는 변수가 유효할 수 있는 범위로, 일반적으로 중괄호로 감싸진 영역을 의미합니다. 즉, 스코프는 변수의 수명을 결정하고 확인할 수 있는 범위입니다. 스코프는 크게 `Local Scope`와 `Global Scope`로 나눌 수 있습니다. `Global Scope`는 어떤 영역에서든 접근이 가능하지만 `Local Scope` 중괄호 감싸진 영역에서 접근이 가능하며, 글로벌 스코프보다 우선순위가 높습니다.

<br>
<br>

### 🐬 Javascript 기본형 데이터 (Primitive Type, 원시 타입)

- 요약 

  원시 자료형은 변경이 불가능한 값을 의미합니다. 원시 자료형에는 6가지인 string, number, boolean, undefined 등이 있습니다. 이러한 원시자료형은 변수가 할당될 때 메모리 고정 크기로 값을 저장하고, 해당 주소를 참조합니다. 불변성의 특징을 가지고 있습니다.예를 들어 let a는 10의 변수를 만들었을 때 a의 대한 값을 2로 변경하면 새로운 메모리가 생성되고, 그것을 참조하는 주소만 변경되어집니다. 참조 자료형은 변경이 가능한 값을 의미합니다. 대표적인 예시에는 객체, 배열, 함수가 있습니다.
  예를 들어 let a에 해당하는 배열을 만들고 let b를 만들어서 a 배열을 선언 했을 때 b에 대한 데이터를 바꾸면 a의 배열 값도 바뀌게 됩니다.



#### (1) 기본

- **객체가 아니면서 method를 가지지 않는 6가지의 타입**이 있다.
- **원시 자료형**은 모두 **하나의 정보**, 즉 **데이터**를 담고 있다.

1. String
2. Number
3. Boolean
4. Symbol
5. Null
6. Undefined

<br>

- ⭐ 원시타입은 변경이 불가능한 값 
- 변수값을 변경하는 것과 값을 변경하는 것을 혼동하는 경우가 많은데
  메모리에 있는 값을 변경할 수 없다는 의미이다. 
  - 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체, 이를 식별하기위해 붙인 이름 
  - 값 : 변수에 저장된 데이터 자체 
- 변수에 값을 재할당할 때 이전에 저장된 메모리 공간의 값을 바꾸는 것이 아니라 새로운 메모리 공간에 재할당하는 값을 저장한다. 즉, 값을 서로 다른 메모리에 할당한다. 
- 그렇기 때문에 원시타입은 불변성을 띈다. 

<br>

#### (2) 객체 타입 

자바스크립트는 객체기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 모든 것이 객체이다. 원시타입을 제외한 나머지 값(함수, 배열, 정규 표현식)은 객체이다. 

- 객체는 0개 이상의 프로퍼티로 구성된 집합이며, key : value로 구성된다. 
- 객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다. 
- js에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 함수도 프로퍼티의 값이 될 수 있다. 

<br>

- ⭐ 객체타입은 변경가능한 값이다. 
- 원시값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시값에 접근하는 것이 가능하다. 즉 원시값을 할당한 변수는 원시값 자체를 값으로 갖는다. 
- 객체를 할당한 변수가 기억하는 메모리주소를 통해 메모리 공간에 접근하면 참조값에 접근할 수 있다. 
- 참조값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체이다. 참조값을 통해 객체에 접근하는 것이 가능하다. 
- 원시값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다. 
- 원시 값을 갖는 변수의 값을 변경하려면 재할당외에는 방법이 없지만, 객체는 변경이 가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경하는 것이 가능하다. 
- 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고, 프로퍼티의 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다. 

<br>
<br>

### 🐬 undefined와 null의 차이점

undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다. 그래서 변수를 참조했을때 undefined가 반환된다면 초기화하지 않은 변수라는 것을 알 수 있다.

null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. (의도적 부재) 이는 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미하며, 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행한다.

<br>
<br>

### 🐬 ==와 ===의 차이점


- 동등 비교(==)     연산자는 좌항과 우항을 비교할 때, 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교한다. 따라서     타입이 다르더라도 암묵적 타입 변환 후에 같은 값이라면 true를 반환한다.
- 일치     비교(===) 연산자는 좌항과 우항의 피연산자가 타입이 같고, 값이 같은 경우에 한하여 true를 반환한다. ⇒ 동등비교(==)는 예측하기 어려운 결과를 만들어내므로, 일치 비교(===) 연산자를 사용하는 것이     권장된다.



<br>
<br>



### 🐬 rest parameters와 spread syntax의 차이는 무엇인가요?

#### (1) rest parameters

매개변수 이름 앞에 세개의 점을 붙여 정의한 매개변수를 의미한다. 
함수로 전달된 인수들의 목록을 배열로 압축할 때 사용되어지며, 일반 매개변수와 함께 사용할 수 있습니다. 하지만 배열로 만들어주기 때문에 마지막 파라미터로 사용해야 합니다. 

<br>

#### (2) spread syntax

spread syntax는 뭉쳐있는 여러 개의 값들을 개별적인 값들의 목록으로 만들때 사용되어집니다. 순서가 있는 배열 또는 문자열을 의미하며, 결과는 값의 목록으로 나타나집니다.

<br>
<br>



### 🐬 변수 선언, 초기화, 할당의 차이점에 대해서 설명하세요. 

변수 선언은 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알리는 단계이고, 초기화는 값을 저장하기 위해 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화하는 단계입니다. 마지막으로 할당 단계에서는 undefined로 초기화 된 메모리에 다른 값을 넣는 것입니다.

<br>
<br>



### 🐬 var, let, const의 차이에 대해 알려주세요. 

- var는 함수 스코프로 함수내에서 모든 변수에 접근이 가능하고, 변수가 선언되기 전에 코드에서 참조될 수 있습니다. 반면에 let, const는 블록 스코프로 블록 외부에서 접근이 불가능하며 초기화가 되기 전에는 코드를 참조할 수 없습니다. 또한 let은 재할당이 가능하고, const는 재할당이 불가능합니다. 요즘에는 var 대신에 let과 const를 주로 사용합니다. 왜냐하면 var의 경우에는 중복된 이름을 선언했을 경우에 오류사항이 나지 않으므로, 배포시에 위험성이 있기 때문입니다.



![image](https://user-images.githubusercontent.com/72599761/204128739-402676c6-c324-40b2-b8ff-8bf9ce335853.png)

<br>


- var : 변수 재선언, 재할당 모두 가능하다, 함수레벨 스코프 
- let : 변수 재선언은 불가능, 재할당 가능(immutable true), 블록레벨 스코프 
- const: 변수 재선언, 재할당 불가능(immutable false), 블록레벨 스코프 

<br>
<br>

##### ⚠️ const의 주의할 점 

상수는 재할당이 안된다고 했지만, const로 된 객체의 속성들은 수정될 수 있다. 

- 기본형과 참조형의 개념을 알아야 하는데, 간단하게 설명하면 원시값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어있는 참조값을 통해 실제 객체에 접근한다. 
- 원시값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없지만, 객체는 변경이 가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 변경하는 것이 가능하다. 
- 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고, 프로퍼티의 값을 갱신할 수도 있으며 프로퍼티를 삭제할 수 도 있다. 


<br>
<br>

### 🐬 변수 호이스팅이란? 

- var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어올려진 것처럼 동작한다. 
- var 키워드로 선언한 변수는 변수 선언이 런타임에서 되는 게 아니라 그 이전단계에서 먼저 실행되기 때문에 변수 선언문 이전에 참조할 수 있다. 
- 할당문 이전에 변수를 참조하면, 언제나 undefined를 반환하게 된다. 

```javascript
// 1. 선언 단계 : 변수 호이스팅에 의해 foo변수가 선언되었다. 
// 2. 초기화 단계 : 변수 foo는 undefined로 초기화된다. 
console.log(foo); // undefined

// 3. 할당 단계
foo = 123;

console.log(foo); //123
```


<br>



⚠️ 변수 선언문 이전에 변수를 참조하는 것은 호이스팅에 의해 에러를 발생시키지는 않지만 가독성을 떨어뜨리고 오류를 발생시킬 여지가 있다. 

<br>

👉 var 키워드의 위와 같은 단점을 보완하여 ES6 문법에서는 let, const가 등장하게 되었습니다. 



<br>
<br>

### 🐬 호이스팅과 Temporal Dead Zone이 어떻게 연관되어있는지 설명하세요.

호이스팅은 함수 안에 있는 선언들을 모두 끌어 올려서 해당 함수 유효 스코프의 최상단에 선언하는 것을 의미합니다. var의 경우 선언단계와 초기화 단계가 함께 진행되어지지만 let은 선언단계와 초기화 단계가 분리되어 진행되어집니다. 그래서 초기화 이전에 변수에 접근하려고 하면 참조에러가 발생되어집니다. 따라서 호이스팅이 일어나면 참조할 수 없는 일시적 사각지대인 TDZ가 생기게 됩니다.



<br>
<br>

### 🐬  값의 복사 (call by value) vs 주소의 복사 (call by reference)

#### 1. 값의 복사(Call By Value)

- `call by value` 란 값이 그대로 복사되는 것을 의미한다. 
- 원시데이터의 경우 값의 복사 (`Call By Value`) 가 일어난다. 

<br>

#### 2. 주소의 복사 (Call by Reference)

- `Call by reference`는 데이터가 있는 공간(주소:메모리의 위치)이 `참조` 되는 것을 의미한다. 
- 객체는 `Call by reference`가 일어난다. 

<br>

https://lamarr.dev/javascript/2020/04/08/04.html



<br>
<br>

### 🐬  깊은 복사와 얕은 복사의 차이에 대해서 설명하세요. 자바스크립트에서 깊은 복사를 하는 방법은 무엇인가요?

#### 1. 깊은 복사 (deep copy)

깊은 복사는 객체가 중첩되어 있는 상황일 때 내부 객체까지 모두 새로 생성된 것을 의미합니다. 이 때 복사된 A객체와 B객체 중 어느 하나를 수정해도 다른 객체에 영향을 미치지 않습니다.

<br>

#### 2. 얕은 복사 (shallow copy)

얕은 복사는 상위 객체만 새로 생성되고 내부 객체들은 참조 관계인 경우를 의미합니다. 같은 주소값을 가리키기 때문에 복사된 A객체와 B객체 중 어느 하나를 수정하면 다른 객체에 영향을 미칩니다. 자바스크립트에서 깊은 복사를 하는 방법은 재귀함수를 이용하여 복사하거나 lodash()라이브러리를 사용하는 방법이 있습니다.

<br>
	<br>

### 🐬  Async/Await과 Promise의 차이 

Promise를 활용할 시에는 .catch()문을 통해 에러 핸들링이 가능하지만, async/await은 에러 핸들링을 할 수 있는 기능이 없어 try-catch()문을 활용해야 합니다. 그리고 Promise는 .then 지옥의 가능성이 있는 반면에 async/await을 활용한 코드는 가독성이 좋습니다. async/await은 비동기 코드가 동기코드 처럼 읽히게 해주며 코드 흐름을 이해하기 쉽게 해줍니다. 



- 에러 핸들링 
  - Promise를 활용할 시에는 .catch()문을 통해 에러핸들링이 가능하지만, async/await은 에러 핸들링을 할 수 있는 기능이 없어 try-catch() 문을 활용
- 코드 가독성 
  - Promise의 .then() 지옥의 가능성 
  - 코드가 길어지면 길어질수록, async/await를 활용한 코드가 가독성이 좋다. 
  - async/await은 비동기코드가 동기 코드처럼 읽히게 해준다. 코드 흐름을 이해하기 쉽다. 


<br>
<br>
	

### 🐬 동기와 비동기의 차이점 

- 동기는 서버에서 요청을 보냈을 때 응답이 돌아와야 다음 동작을 수행하는 것이 가능합니다. 
- 비동기는 반대로 요청을 보냈을 때 응답 상태와 상관없이 다음 동작을 수행할 수 있습니다. 

<br>
<br>

### 🐬 클로저(closure)란? 

- 클로저는 내부함수의 변수가 외부함수의 변수에 접근할 수 있는 것을 의미합니다. 즉 클로저 함수 안에서는 지역변수, 외부함수의 변수, 전역변수 모두 다 접근이 가능합니다. 클로저는 변경이 되지 않아야 하지만 해당 값을 읽고 싶을 때 주로 사용되어집니다.
- 클로저는 정보를 은닉 즉, 캡슐화가 필요할 때 사용되어집니다. 클로저 함수를 통해서 중요한 데이터가 외부로부터 오염되는 것을 막을 수 있습니다. 뿐만 아니라 템플릿처럼 하나의 함수를 재사용 하고 싶을 때도 사용되어집니다.

- 외부함수에 접근할 수 있는 내부함수 혹은 이러한 원리를 일컫는 용어인데 
- 스코프에 따라서 내부함수의 범위에서는 외부 함수 범위에 있는 변수에 접근이 가능하지만 
- 그 반대는 실현이 불가능하다는 개념이다. 

- 반복문과 비동기 함수가 만날 때 문제가 자주 발생하는데, 클로저의 특성을 사용해서 해결할 수 있습니다. 

<br>
<br>


### 🐬 콜스택(Call stack)과 힙(Heap) 

자바스크립트 엔진이 자바스크립트를 실행할 때 원시타입 및 참조 타입을 저장하는 메모리 구조로 콜 스택과 힙을 가진다. 

- 콜스택 : 원시타입 값과 함수 호출의 실행 컨텍스트를 저장하는 곳이다. 
- 힙 : 객체, 배열, 함수와 같이 크기가 동적으로 변할 수 있는 참조 타입 값을 저장하는 곳이다. 



<br>
<br>

### 🐬 이벤트 루프 (Event Loop) 

- Javascript event loop는 call stack이 비어있는 경우, task queue에서 대기하던 call back을 call stack으로 옮겨서 callback을 실행시켜주는 역할을 합니다. 

<br>

자바스크립트는 단일 스레드(single-threaded) 기반 언어로, 자바스크립트 엔진은 단일 콜스택을 갖는다. 즉, 한번에 하나의 작업만 동기적으로 처리할 수 있습니다. 그렇기 때문에 자바스크립트 엔진은 어떤 작업을 하면 중간에 어떤 함수도 실행될 수 없어 사용자는 많은 시간을 기다려야 합니다.  이러한 문제를 해결하고자 함수 호출을 관리하는 call stack과 비동기 작업 처리를 위해 Web API가 함께 작업을 처리하게 됩니다. 
<br>

비동기 코드들은 웹 API의 처리를 거쳐 태스크 큐에 쌓습니다. 이 때 작업이 다 완료되어서 call stack이 비어있게 되면 task queue에 담겨있는 callback 함수를 다시 call stack으로 담아서 callback을 실행시키게 됩니다. 이 작업이 event loop입니다. 

<br>
<br>

### 🐬 Promise와 Callback, async/await 의 특징과 차이점에 대해서 설명하세요.

- callback : 다른 함수의 인자로 전달되는 함수 
  - 비동기 작업을 해결하기엔 충분했지만 함수에 담아서 사용해야 하므로 코드가 직관적이지 않아서 "callback hell"현상이 일어났습니다. 
  - 이 문제를 해결하고자 promise가 탄생하게 되었습니다. 
- promise
  - promise는 성공과 실패라는 executor를 전달해주어야 합니다. 이때 작업에 성공했을 경우에는 resolve, 실패했을 경우는 reject라고 합니다. 
  - 성공시에는 resolve 함수에서 전달된 인자가 인스턴스의 결과값으로 나오게 됩니다. 
  - 프로미스 인스턴스는 대기상태인 pending, 성공인 fulfilled, 실패한 rejected 3가지 중 하나의 상태를 가집니다. 
  - promise는 then과 catch 메소드로 프로미스를 리턴하기에 promise chaining이 가능합니다. 
  - 하지만  연속되는 비동기 작업이 순서대로 작동되어야 하는 경우 콜백지옥처럼 프로미스 지옥이 발생하였습니다. 
- async/await 
  - promise를 조금더 쉽게 다룰 수 있게 되었다. 
  - async/await 키워드만 적절히 사용하면 기존 함수를 작성하는 문법을 그대로 살릴 수 있습니다. 
  - async 함수를 실행하면 함수 내 리턴값 여부에 상관없이 Promise가 리턴되며, 함수 내의 리턴 값은 Promise return 값으로 전달되어집니다. 
  - await 키워드는 async 함수 내에서만 사용이 가능하며 응답이 올때까지 코드 읽기를 멈췄다가 요청이 오고나서야 다음코드를 실행하는 문법입니다. 이때 await로 실행된 코드는 Promise가 아닌 Promise의 result 값을 반환합니다.

<br>
<br>

### 🐬 Promise와 Callback의 차이점은

- callback을 사용하면 비동기 로직의 결과값을 처리하기 위해서는 callback안에서만 처리를 해야하고, 콜백 밖에서는 비동기에서 온 값을 알 수가 없음
- 하지만 promise를 사용하면 비동기에에서 온 값이 promise 객체에 저장되기 때문에 코드 작성이 용이

<br>
<br>


###  🐬 Cors가 무엇이며 어떻게 해결 가능한가? 

다른 도메인에서 리소스 요청시 cross-origin HTTP에 의해 요청을 하는데, 대부분의 브라우저는 보안 상의 이유로 이 요청을 제한한다. 이를 동일 오리진 정책 (Same Origin Policy) 이라고 한다. 

 <br>

요청을 보내기 위해서 요청 보내는 대상과 프로토콜이 같아야하고, 포트도 같아야한다. JSONP을 통해 해결하거나 특정 HTTP 헤더를 추가하여 이 이슈를 해결할 수 있다. 이와 같이 타 도메인 간 자원을 공유할 수 있게 해주는 것을 Cross Origin Resourse Sharing, 줄여서 cors라고 한다.

<br>
<br>

### 🐬 크로스 브라우징이란? 

크로스 브라우징은 웹 표준에 따라 서로 다른 os 또는 플랫폼에 대응하는 것을 말한다. 브라우저별 렌더링 엔진이 다른 상황 등 어떠한 상황 속에서도 문제없이 동작하게 하는 것을 목표로 한다.


<br>
<br>


### 🐬 이벤트 버블링이란? 

- 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작합니다. 

<br>
<br>


### 🐬 부모에서 자식으로 이벤트를 상속하는 방법 

- 이벤트 캡쳐링으로 부모에서 자식으로 이벤트를 상속하는 것이 가능하다. 
- 이벤트 캡쳐링은 이벤트 버블링과 반대로 상위 요소에서 하위 요소로 탐색하며 이벤트를 전파하는 방식이다. (부모 -> 자식)

<br>
<br>

### 🐬 이벤트 버블링을 활용하는 방법 

- 하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소릐 이벤트들을 제어하는 방식으로 이벤트 버블링을 활용 (이벤트 위임)
- 이벤트 버블링을 응용하여 부모 엘리먼트에 리스너를 위임하여 부착하면, 리스너의 개수를 1개로 줄여 최적화 가능 



<br>
<br>

### 🐬 순수함수란 무엇인가요?

순수 함수란, 오직 함수의 입력만이 함수의 결과에 영향을 주는 함수를 의미합니다. 매개 변수를 통해 함수 내부로 전달된 인수에만 의존해 반환 값을 만들며, 매개변수로 전달된 값을 수정하지 않는 함수를 의미합니다.

<br>
<br>

### 🐬 고차 함수(higher-order function)의 정의는 무엇인가요?

고차 함수는 다른 함수를 매개 변수로 사용하여 어떤 데이터를 처리하거나, 결과로 함수를 반환하는 함수입니다. 고차 함수는 반복적으로 수행되는 어떤 연산을 추상화하기 위한 것입니다. 전형적인 예시는 배열과 함수를 인수로 취하는 `map`입니다. `map`은 고차 함수를 사용하여 배열의 각 항목을 변환하고, 변환된 데이터로 새로운 배열을 반환합니다. JavaScript에서 흔히 볼 수 있는 다른 예로 `forEach`, `filter`, `reduce`가 있습니다.



<br>
<br>



### 🐬 객체나 배열에 대한 디스트럭쳐링 예시를 들 수 있나요?

디스트럭쳐링은 ES6에서 사용할 수 있는 표현식으로 **객체나 배열의 값을 추출하여 다른 변수에 배치하는 간결하고 편리한 방법**을 제공합니다.

**배열 디스트럭쳐링**

```js
// 변수 할당.
const foo = ['one', 'two', 'three']

const [one, two, three] = foo
console.log(one) // "one"
console.log(two) // "two"
console.log(three) // "three"
// 변수 교환
let a = 1
let b = 3

;[a, b] = [b, a]
console.log(a) // 3
console.log(b) // 1
```

**객체 디스트럭쳐링**

```js
// 변수 할당.
const o = { p: 42, q: true }
const { p, q } = o

console.log(p) // 42
console.log(q) // true
```



<br>
<br>

### 🐬 ES6 템플릿 리터럴

문자열을 생성하는데 많은 유연성을 제공한다. 

템플릿 리터럴을 사용하면, 대신 이렇게해도 같은 출력을 만들 수 있습니다.

```js
const person = { name: 'Tyler', age: 28 };
console.log(`Hi, my name is ${person.name} and I am ${person.age} years old!`);
```



## 웹 (WEB) 

### 🐬 HTTP 

클라이언트-서버 모델을 따르는 프로토콜로 TCP/IP 위에서 동작하며 80번 포트를 사용하여 통신한다. 첫번째 표준은 HTTP/1.1이며 이후로 HTTP/2 및 HTTP/3가 등장하였다. 여기선 HTTP/1.1의 내용을 정리한다. 

<br>
<br>

### 🐬 HTTP의 특징 

1. 비연결지향 (Connectionless)

   클라이언트가 서버에게 리소스를 요청한 후 응답을 받으면 연결을 끊어버리는 특징이다. 연결을 유지하게 되면 서버에 많은 부담을 줄 수 있기 때문에 상당히 많은 클라이언트에게 요청을 받는 웹서버의 경우 응답을 처리했으면 연결을 끊는다. 이로 인해 서버의 부담을 줄일 수 있지만, 리소스를 요청할 때마다 연결해야 하는 오버헤드 비용이 발생한다. 이를 해결하기 위해선, 요청 헤더의 `Connection: keep-alive` 속성으로 지속적 연결 상태(Persistent connection)를 유지할 수 있다. 즉, 요청을 할 때마다 연결하지 않고 기존의 연결을 재사용하는 방식이다. HTTP 1.1 부턴 지속적 연결 상태가 기본이며 이를 해제하기 위해선 명시적으로 요청 헤더를 수정해야 한다.

2. 무상태성 

   각각의 요청이 독립적으로 여겨지는 특징으로, 서버는 클라이언트의 상태를 유지하지 않는다. 즉, 각 클라이언트에 맞게 리소스를 응답하는 것은 불가능하다. 이를 해결하기 위해 쿠키나 세션 또는 토큰 방식의 OAuth 및 JWT가 사용된다. 

<br>
<br>

### 🐬 ★ HTTP Method 

클라이언트가 서버에 요청방법을 정의하는 것으로 주어진 리소스에 수행하길 원하는 행동을 나타낸다. 

- **GET**: 서버에게 조회할 리소스를 요청한다. (Read, 조회)
- **POST** : 서버에게 본문(body)에 생성할 데이터를 삽입하여 전송한다. (CREATE, 생성)
- **PUT** : 서버에게 본문에 수정할 데이터를 삽입하여 전송한다. (UPDATE, 수정)
- **DELETE** : 서버에게 삭제할 리소스를 요청한다. (DELETE, 삭제)
- **PATCH** : PUT과 비슷하지만 일부만 수정한다는 점에서 다르다.

<br>
<br>

### 🐬 HTTP 응답 상태코드 

서버가 클라이언트에게 요청을 받으면 응답상태에 따라서 다른 상태코드를 클라이언트에게 돌려준다. 

- **1xx (요청에 대한 정보)** : 요청을 받았으면 작업을 계속한다.
- 2xx (성공) : 요청을 성공적으로 수행했다.
  - 200(성공), 201(새 리소스 작성), 202(요청 접수, 아직 처리는 안함)
- 3xx (리다이렉션) : 클라이언트가 요청을 마지기 위해 추가적인 동작을 취해야 한다.
  - 300(여러개의 응답, 선택해야 함), 301(영구이동, 요청한 페이지가 영구적으로 이동됨), 302(임시이동, 현재 응답잉 다른 페이지이긴 하지만 임시적임)
- 4xx (클라이언트 오류) : 클라이언트에 오류가 있다.
  - 401(권한 없음), 403(금지됨, 리소스에 대한 권한 없음), 404(찾을 수 없음, 서버에 없는 페이지)
- 5xx (서버 오류) : 서버에 오류가 있다.
  - 500(내부 서버오류), 501(요청수행 기능없음, 메서드 인식불가), 503(서비스 사용불가)

<br>
<br>

### 🐬 HTTPS 란? 

- HTTPS (HTTP Secure)는 HTTP protocol의 암호화된 버전 
- 클라이언트와 서버간의 모든 커뮤니케이션을 암호화하기 위하여 SSL이나 TLS를 사용한다. 
  - SSL 인증서
    - SSL 인증서는 사용자가 사이트에 제공하는 정보를 암호화
  - TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지함
    - TSL은 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정되거나 손상되는 것을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공
- 이 커넥션은 클라이언트가 민감한 정보를 서버와 안전하게 주고받도록 해준다. 

![image](https://user-images.githubusercontent.com/72599761/204128764-81021f2c-3db3-422c-90e6-bebc8670dd5b.png)


HTTPS(HyperText Transfer Protocol over TLS/SSL)는 **기존의 HTTP를 암호화한 프로토콜** 로 보안이 강화된 버전이다. 약어에서의 "S"가 원래 SSL(Secure Socket Layer)의 약자였지만 SSL 버전 3.1부터 TLS(Transport Layer Security)로 명칭이 바뀌고 TLS와 혼용하고 있다. TCP의 연결이 이루어진 후 TLS를 통해 암호화 설정이 되고 통신을 하는 방식이다.

<br>
<br>

### 🐬 브라우저에서 주소창에 url 입력시 어떤일이 일어나는가?

1. 웹 브라우저에 URL을 입력하고 Enter 키를 누릅니다. 
2. 웹 브라우저가 도메인명의 IP 주소 조회 
3. 웹 브라우저가 서버와의 TCP 연결 시작 
4. 웹 브라우저가 HTTP 요청을 서버로 전송 
5. 웹 서버가 요청을 처리하고 응답을 다시 전송 
6. 웹 브라우저가 콘텐츠 렌더링 

<br>
<br>

### 🐬 URI vs URL 

![image](https://user-images.githubusercontent.com/72599761/204128774-1ec65148-38fa-4adb-a809-de0072e90540.png)


- URL : 서버에 있는 파일의 위치 
- URI : 서버에 있는 자원의 위치 

<br>
<br>

### 🐬 RESTFul API란? 

- 요약 

  Rest API는 Rest를 기반으로 서비스 API를 구현한 것입니다. Rest라는 것은 자원의 표현, 즉 이름으로부터 자원의 정보를 주고받는 것을 의미합니다. 그래서 자원을 URI로 표현하고, 자원에 대한 행위는 HTTP Method로 표현합니다. 

   <br>

  Restful이라는 것은 Rest의 원리를 잘 따르는 시스템입니다. 
  자원을 URI로, 행위에 맞는 적절한 HTTP method를 사용한 것입니다. 
  Restful하지 않은 경우를 예로 들며 CRUD 기능을 모두 POST만으로 처리한것을 Restful 하지 않다고 할 수 있습니다. 

  <br>

  

- RESTFul은 REST의 설계 규칙을 잘 지켜서 설계된 API를 RESTful한 API 
  - REST API : REST의 특징을 기반으로 서비스 API를 구현한 것 
  - 각 요청이 어떤 동작이나 정보를 위한 것인지를 그 요청의 모습 자체로 추론이 가능한 것 
  - URI는 정보의 자원을 표현 / 자원에 대한 행위는 HTTP Method(GET, POST, PUT, PATCH, DELETE)로 표현 / 행위는 URI에 포함하지 않음 

<br>
<br>

### 🐬 GET, POST 방식의 차이점

- GET, POST 방식 모두 브라우저가 서버에 요청하는 것 
- GET, POST 방식 차이점 
  - GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용한다. 
  - GET은 URL 파라미터에 요청하는 데이터를 담아보내기 때문에 HTTP 메세지에 body가 없으나, POST는 body에 데이터를 담아 보내기 때문에 당연히 HTTP 메시지에 body가 존재 
    - GET 요청은 멱등이며, POST는 멱등이 아님 
      - 멱등성 : 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질

<br>
<br>

### 🐬 AJAX란 무엇인가

- Asynchronous JavaScript and XML의 약자
- 빠르게 동작하는 동적인 웹 페이지를 만들기 위한 개발 기법의 하나
- Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있음. 즉 Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹 페이지의 일부분에만 표시 가능

<br>
<br>

### 🐬 프레임워크 vs 라이브러리 

프레임워크는 프로그램의 흐름 자체를 개발자가 아닌 프로그램이 갖지만, 라이브러리는 흐름에 대한 제어를 하지 않고 개발자가 필요한 부분만 가져와서 사용하는 형태가 라이브러리입니다.  즉, 제어권이 프로그램에게 있으면 프레임워크, 개발자가 제어권을 갖고 있으면 라이브러리이다. 

<br>
<br>

## 네트워크 (Network)

### 🐬 TCP란 무엇인가?

- 인터넷 상에서 데이터를 메시지 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다. (Transmission Control Protocol)

- TCP (전송 제어 프로토콜)은 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜 
- TCP는 에러 없이 패킷이 신뢰할 수 있게 전달되었는지 보증해주는 것이다. 
- TCP는 동시제어가 가능하다 -> 이는 초기 요청이 작게 시작해도 컴퓨터들과 서버들의 대역폭의 깊이가 증가해도 네트워크가 지원할 수 있다는 것을 뜻한다. 



- 패킷이란? 
  - 인터넷 내에서 데이터를 보내기 위한 경로 배정을 효율적으로 하기 위해서 데이터를 여러개의 조각들로 나누어 전송을 하는데 이 때 이 조각을 패킷이라고 한다. 

<br>
<br>

### 🐬 TCP와 UDP의 차이점은? 

TCP는 신뢰성있는 통신을 위해 사용하는 프로토콜로 높은 신뢰성을 보장하지만, UDP보다는 속도가 느립니다. 3 Way, 4Way handshake로 서버와 클라이언트가 1:1로 통신을 합니다. 흐름 제어와 혼잡 제어가 이루어지게 됩니다. 

UDP는 비연결형 프로토콜로, 손상된 데이터에 대해서 재전송하지 않는 특징을 가지고 있습니다. 신뢰성이 낮지만, TCP보다 속도가 빨라서 스트리밍 같은 서비스에 주로 사용됩니다. 마지막으로 1:1, 1:N, N:N으로 연결이 가능합니다. 



- TCP : 신뢰성이 높은 프로토콜이다. 

  - 신뢰성이란 무엇인가, 내가 전달한 것이 보장된다는 의미이다. 상대방이 받았는지 확인할 수 있음. 

  - 느리다.

  - 3 Way Hand Shaking 

  - 흐름제어

  - 혼잡제어 

 

- UDP: 빠른 프로토콜이다. 
  - 일대일 일대다 통신



![image](https://user-images.githubusercontent.com/72599761/204128795-9dc4657f-576d-41aa-b6ec-2fd8bf2e187b.png)


<br>
<br>

### 🐬 OSI 7 계층이란? 

OSI 7계층은 인터넷 환경에서 통신하기 위해 네트워킹에 대한 표준을 7계층으로 나눈 것입니다. 

크게 7계층이 있습니다. 물리계층, 데이터 링크계층, 네트워크 계층, 전송계층, 세션계층, 표현계층, 그리고 응용계층이 있습니다. 


<br>
<br>


## 운영체제 (OS)  

### 🐬 메모리 구조 

![image](https://user-images.githubusercontent.com/72599761/204128815-90e34819-9fca-4a85-983d-2acbe0abe894.png)


메모리 공간은 **코드, 데이터, 힙, 스택** 총 4종류가 있습니다. 

**코드**는 소스코드가 들어가는 부분이고
**데이터**는 전역변수, 정적변수가 할당되는 부분이에요
**힙**은 사용자가 직접 관리하는 영역으로 데이터가 동적으로 할당되는 공간이구요
**스택**은 함수의 호출정보, 지역변수, 매개변수들이 저장되게 됩니다. 


<br>
<br>


### 🐬 프로세스와 스레드의 차이 

- 프로그램
  - 어떤 작업을 위해 실행할 수 있는 파일 

- 프로세스 

![image](https://user-images.githubusercontent.com/72599761/204128832-935313c7-73d0-4669-809a-e411f78578be.png)


  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램 
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스 (독립적인 개체)
  - 동적인 개념으로는 실행된 프로그램을 의미 
  - 프로세스는 각각 독립된 메모리 영역 (code, data, stack, heap의 구조)을 할당받는다. 
  - 기본적으로 프로세스당 최소 1개의 스레드 (메인 스레드)를 갖고 있다. 

- 스레드 

  ![image](https://user-images.githubusercontent.com/72599761/204128857-fe739c11-6662-464c-be5f-9ad407a31a50.png)

  - 프로세스 내에서 실행되는 여러 흐름의 단위 
  - 프로세스의 특정한 수행경로 
  - 프로세스가 할당받은 자원을 이용하는 실행의 단위 
  - 스레드는 프로세스 내에서 각각 stack만 따로 할당 받고, code, data, heap 영역은 공유한다. 
  - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다. 

<br>
<br>

### 🐬 멀티 프로세스와 멀티 스레드의 차이 

- 멀티 프로세스 
  - 하나의 응용프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하는 것이다. 
- 멀티 스레드 
  - 하나의 응용 프로그램을 여러개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다. 
  - 윈도우, 리눅스 등 많은 운영체제들이 멀티 프로세싱을 지원하고 있지만, 멀티 스레딩을 기본으로 하고 있다. 
  - 웹 서버는 대표적인 멀티 스레드 응용 프로그램이다. 

- 멀티 프로세스 대신 멀티 스레드를 사용하는 이유? 
  - 프로그램을 여러개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이다. 
    1. 자원의 효율성 증대 -> 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어든다. 
    2. 처리 비용 감소 및 응답시간 단축 -> 프로세스간의 통신보다 스레드 간의 통신 비용이 적고, 스레드간의 전환속도가 더 빠르다. 

![image](https://user-images.githubusercontent.com/72599761/204128882-475cccfe-06aa-4e00-984f-011001031ee9.png)

<br>

- 참고 

https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

<br>
<br>



### 🐬 Cookie vs Session 

- 요약

http는 상태와 연결에 대한 정보를 저장하지 않아, 이를 도와주는 것이 쿠키와 세션입니다. 

우선, 쿠키는 사용자 정보가 기록된 텍스트 파일인데요. 
브라우저에 저장되면서, 통신할 때 (HTTP) 헤더에 포함되어 전송되게 됩니다. 
그리고 HTTP 통신 중에 쿠키 정보가 노출될 수 있기 때문에 보안에 취약하다는 특징을 가지고 있습니다. 

 

두번째는 세션인데요. 세션은 사용자의 정보를 서버에 저장합니다. 
이 때 브라우저가 종료될 때까지 유지되게 됩니다. 
그리고 서버에 저장되기 때문에 보안이 강하다는 특징을 가지고 있습니다. 



- 쿠키와 세션을 사용하는 이유

HTTP는 상태가 없는(Stateless) 프로토콜이기 때문에 사용자가 웹 브라우저를 통해서 특정 웹사이트에 접속하게 될 경우 어떤 사용자가 접속했는지에 대한 정보를 파악할 수 없다. 따라서 쿠키 또는 세션을 사용하여 사용자를 구분하고 각 사용자에 맞는 정보를 제공한다. 



HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용한다.
HTTP 특징에는 비연결성, 비상태성이라는 특징을 보완하기 위해서 사용한다. 
서버와 클라이언트 간에 통신을 할 때 통신이 연속적으로 이어지지 않고 끊긴다면 서버는 클라이언트가 누구인지 계속 인증해야 한다.

 

1. 비연결성 : 클라이언트가 서버에 요청했을 때 그 요청에 맞는 응답을 보낸 후 연결을 끊는 처리방식 
2. 비상태성 : 클라이언트의 상태정보를 가지지 않는 서버처리방식 

첫번째 통신에서 서버와 클라이언트 간에 데이터를 주고 받았다고 해서 두번째 통신에서는 데이터를 유지하지 않는다. 



#### 1. Cookie 

쿠키란 클라이언트의 웹 브라우저에 저장되는 작은 데이터 조각으로 서버가 클라이언트의 요청을 식별하는데 사용이 된다. 쿠키를 활용해서 사용자를 구분하는 게 매우 유용하지만, 클라이언트가 수정할 수도 있고, 해커가 탈취할 수도 있기 때문에 보안에 취약하다. 따라서 아이디 및 비밀번호와 같은 민감한 정보들을 저장하는데 사용하지는 않고, 아래와 같은 목적으로 사용한다. 

- 세션 ID 관리, 서버에 저장해야할 민감한 정보에 대한 식별자 ID
- 개인화, 사용자 선호 및 테마
- 트래킹, 사용자 행동 기록 및 분석 



#### 2. Session 

세션이란 브라우저가 서버에 연결되어 있는 동안 유지하는 데이터 집합이다. 사용자가 웹 사이트에 방문하여 서버에 요청을 보내게 되면, 사용자의 정보를 서버에 저장하고, 그 정보를 식별할 수 있는 세션 ID를 set-cookie 헤더로 클라이언트에게 전송한다. 위에서 말했던 것처럼 클라이언트는 쿠키로 세션 ID를 관리하고 해당 서버에 요청할 때마다 Cookie 헤더에 세션 ID를 포함시켜 전송하기 때문에 서버는 클라이언트를 식별하여 그에 맞는 정보를 응답으로 줄 수 있게 된다. 따라서 아래와 같은 목적으로 사용한다고 할 수 있다. 

- 민감한 정보 관리, 사용자의 비밀번호 및 개인정보 



#### 차이점 

- 쿠키 
  - 클라이언트 쪽에 저장한다. (웹 브라우저)
  - 브라우저가 꺼져도 삭제되지 않고 사용자가 삭제하거나 정해진 시간만큼 유지된다. 
  - 문자열만 저장할 수 있다. 
  - 클라이언트에서 보내기 때문에 속도가 빠르다.
  - 민감한 데이터를 스니핑 당할수도 있기 때문에 보안에 취약하다. 
- 세션 
  - 서버쪽에 저장한다. (서버의 메모리 혹은 데이터베이스)
  - 브라우저가 꺼질 경우 삭제된다. 
  - 문자열 뿐만 아니라 객체도 저장할 수 있다. 
  - 서버쪽에서 처리하기 때문에 속도가 비교적 느리다. 
  - 서버에서 민감한 데이터를 갖고 있기 때문에 비교적 보안이 좋다. 






## 디자인 패턴 


### 🐬 아토믹 디자인 패턴에 대해 아는가?

- 가장 작은 컴포넌트 단위를 원자로 설정하고 이를 바탕으로 상위 컴포넌트를 만들어 코드 재사용을 최대화하는 방법론
- 원자 -> 분자 -> 유기체 -> 템플릿 -> 페이지


<br>
<br>


## 자료구조 

###  🐬 Array vs LinkedList

- Array 의 element 들은, 인접한 memory 위치에 저장 / Memory 는 Array 가 선언되자 마자 Compile time 에 할당
- LinkedList 의 element 들은, memory 어딘가에 저장 / Memory 는 새로운 node 가 추가될 때 runtime 에 할당
- 데이터 접근이 주 업무일 경우 → Array / 데이터 수정이 주 업무일 경우 → Linked List


<br>
<br>




## 배포 

### 🐬 CloudFront를 사용해본적이 있나요? 사용해봤다면, CloudFront로 배포하는 이유를 설명해주세요.

CloudFront는 AWS에서 제공하는 CDN 서비스 입니다. 멍냥마켓이라는 프로젝트를 진행할 대 유저의 현재 위치를 받아오기 위해서는 HTTPS를 사용해야만 했습니다. S3는 HTTP만 지원이 되는 반면에 cloud front는SSL인증서를 발급받으면 HTTPS로 리다이렉트가 가능하다는 장점이 있었습니다. 그리고 CDN을 통한 페이지 응답 속도가 빠르기 때문에 사용하게 되었습니다.



#### ✨12-1. 클라우드 프론트란? 

- 클라우드 프론트는 짧은 지연시간과 빠른 전송 속도로 데이터, 동영상, 애플리케이션 및 API를 전세계 고객에게 안전하게 전송하는 고속 콘텐츠 전송 네트워크 (CDN) 서비스이다.

- 컨텐츠를 제공하는 서버와 실제 요청 지점 간의 지리적 거리가 매우 먼 경우 or 통신 환경이 안 좋은 경우 
- 요청 지점의 CDN을 통해 빠르게 콘텐츠 제공이 가능하다. 
- cloud front 서비스는 엣지 로케이션을 통해 콘텐츠를 제공한다. 
- 엣지 로케이션 : 컨텐츠가 캐싱되고 유저에게 제공되는 지점.  
	

<br>
<br>

### 🐬 CI와 CD 

#### CI (Continuous Integration, 지속적 통합)

CI는 빌드와 테스트를 자동화해서 공유 저장소에 병합시키는 프로세스를 뜻한다. git과 같은 버전관리 시스템을 사용할 때 여러명의 개발자가 하나의 공유 저장소를 사용하는 경우가 많다. 이렇게 되면 새로운 코드의 변경 사항이 저장소에 통합되지 않을 경우 서로 충돌할 수 있다. 따라서 빌드/테스트 자동화부터 코드의 일관성(Consistency)을 제공하기 때문에 지속적으로 통합한다는 용어를 사용하는 것이다. 



#### CD (Continuous Delivery/Deploy, 지속적 전달/배포)

CD는 CI의 빌드/테스트를 통해서 정상적으로 수행됨을 확인하면 이는 배포를 수동으로 하느냐 자동으로 하느냐에 따라 2가지로 나뉜다.

- 지속적 전달

  : 프로덕션 배포를 위한 상태가 되고 배포 자체는 수동으로 실행한다.

  - 개발팀과 비즈니스팀간의 커뮤니케이션 부족 문제를 해결한다.

- 지속적 배포

  : 프로덕션까지 자동으로 배포한다.

  - 어플리케이션의 제공 속도를 증가시킨다.

<br>
<br>
