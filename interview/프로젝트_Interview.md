### 🐬 Debounce 와 Throttle 차이점

<br>

디바운싱은 일정 시간 내에 요청이 들어오는대로 받아주지만 결국 실행하는 건 가장 마지막 요청이고, 쓰로틀링은 일정 시간 내에 요청을 한번에 하나만 들어준다. 최초 요청을 수행하는 동안 다른 요청을 받아 들이지 않는다.
나는 디바운싱 검색어 api 호출, 찜버튼 어뷰징에 사용함.
쓰로틀링은 주로 스크롤 이벤트에 많이 사용함.

<br><br>

### useDebounce hook

useEffect는 컴포넌트가 렌더링 될 때 실행되는 함수입니다. 따라서 useEffect 내부의 코드는 컴포넌트가 렌더링 될 때 마다 실행된다고 생각하시면 됩니다. 위의 코드에서는 setTimeout을 사용하여 특정 시간이 지난 후 전달 받은 value의 값을 변경하는 것을 알 수 있습니다.

<br>

useEffect 내부에서 return을 하게 되면 컴포넌트가 제거 될 때 해당 코드들이 실행됩니다. 위의 코드에서는 컴포넌트가 제거 될 때 clearTimeout을 활용하여 setTimeout의 시간을 초기화 시킵니다.

<br>

useEffect의 두 번째 인자로 배열을 전달하게 되면 배열에 포함된 값이 변할 때만 useEffect를 호출하게 됩니다. 위에서는 value값이 변할 때만 useEffect를 호출하게 될 것입니다.

<br>

⭐⭐ 0.5초 안에 다른 이벤트가 발생하지 않는다면 setDebouncedValue가 실행되어 바뀐 값이 return 되고 다른 이벤트가 발생하면 기존 값이 그대로 return 됩니다.

<br><br>

### 클라우드 프론트

⭐ 클라우드 프론트는 짧은 지연시간과 빠른 전송 속도로
데이터, 동영상, 애플리케이션 및 API를
전세계 고객에게 안전하게 전송하는
고속 콘텐츠 전송 네트워크 서비스이다.

<br>

⭐ 콘텐츠를 제공하는 서버와
실제 요청 지점간의 거리가 매우 먼 경우,
통신 환경이 안 좋은 경우

<br>

⭐ cloud front 서비스는
엣지 로케이션(컨텐츠가 캐싱되고 유저에게 제공되는 시점)을 통해 콘텐츠를 제공한다.

<br><br>

### 아토믹 디자인 패턴의 장단점

    가장 작은 컴포넌트 단위를 원자로 설정하고 단계별로 추상적인 것에서 구체화하는 단계를 가진다. 이 과정을 통해 확장하면서 최종 콘텐츠를 보여줄 수 있다.
    원자(atom) -> 분자(molecule) -> 유기체(organism) -> 템플릿(template) -> 페이지(page)

<br>

    (1) 장점
    - 디자인 시스템 구성에 있어서 가이드라인으로 활용할 수 있다.
    - 애플리케이션과 분리하여 컴포넌트를 개발하고 테스트할 수있고
    스타일 가이드와 같은 도구에서 볼 수있다.
    - 컴포넌트 재사용성이 극대화된다.

<br>

    (2) 단점 - 의존성이 복잡하다.

<br><br>

### 🐬 CSS in JS(styled component)의 장단점에 대해서 설명하세요.

<br>

#### - 장점

- class 명이 빌드시 유니크한 해시값으로 변경되기 때문에 기존의 복잡한 class 명명 규칙을 해결해줍니다.
- 컴포넌트 단위로 추상화되기 때문에 css 파일 간의 의존성을 신경쓰지 않아도 됩니다.
- 컴포넌트와 css가 동일한 구조로 관리되기 때문에 불필요해진 css를 관리하기 위해서 별도의 리소스를 투입할 필요가 없습니다.
- css 컴포넌트 스코프에서만 적용되기 때문에 우선순위 문제가 발생하지 않습니다.

<br>

#### - 단점

- 번들의 크기가 커진다는 단점이 있습니다. CSS in JS를 사용하기 위해서는 여러 라이브러리를 사용하는데 라이브러리 추가는 곧 번들 사이즈가 증가함을 의미합니다.
- 번들 사이즈가 커지게 되면 다운로드 시간도 오래 걸리기 때문에 사용자 경험에 치명적이게 됩니다.
- CSS in JS는 자바스크립트가 모두 로딩된 후 css 코드가 생성되기 때문에 더 느려집니다.

드가 생성되기 때문에 더 느려집니다.

<br><br>

### Css-in-js : 자바스크립트 코드에서 css를 작성하는 방식을 의미

(1) 장점

⭐ js 와 css 사이에 상수나 함수 상태 공유 가능!!!
⭐ css 간의 의존관계를 관리
⭐ 클래스 이름 작성 안해도됨!! => 유니크한 해시값으로 변환
환
⭐ css 모델을 문서레벨이 아닌 컴포넌트 레벨로 추상화

<br>

(2) 단점
⭐ 러닝커브
⭐ 별도의 라이브러리 설치
⭐ 번들 크기 증대 -> 퍼포먼스가 느림.

사용자 경험이 더 중요할 경우…

다만 본인의 경험에 비추어 봤을 때 작업자의 성향이나 판단이 필요한 부분이나 개발 효율성에 중점을 둔 컴포넌트 위주의 프로젝트라면 CSS-in-JS를 고려하는 것이 좋다. 필요한 컴포넌트 페이지의 CSS 스타일 요소만 로딩하기 때문이다. 반면 사용자 편의에 방점을 둔 인터렉티브한 웹 프로젝트라면 랜더링 시 모든 CSS 스타일 요소를 로딩하는 CSS-in-CSS 방식을 권장하는 바이다.

<br><br>

### 리덕스를 사용한 이유??

    1. Context API를 사용해서 상태 관리를 하면 부분적인 상태 변경이 어려워진다.
    별도의 Provider를 이용하여 렌더링을 제어하려고 해도 자식 요소들 전체가 다시 렌더링 해야하는 문제가 생긴다.
    - 컴포넌트 상태를 공통된 상위 컴포넌트까지 끌어올려 공유할 수 있지만
    이 과정에서 거대한 트리가 리렌더링 되기도 한다.

<br>

    2. 리덕스 툴킷
    리덕스보다 보일러플레이트를 줄여준다.

    Redux는 Flux 아키텍처 기반(데이터 흐름이 단방향 )

<br>

    3. 리코일
    ⭐ 리코일은 es5 문법으로 변환되지 않다는 단점이 있기 때문에
    사용 x,

    상태 데이터가 atoms -> selectors -> 컴포넌트 순서로 흐르는 것을 말한다.

<br>

    1. Recoil은 Atomic 모델 기반(Atom -> selector를 거쳐 컴포넌트로 전달되는 하나의 data-flow를 가지고 있어, 복잡하지 않은 상태 구조를 가지고 있다.)

<br>

    2. Atom -> selector를 거쳐 컴포넌트로 전달되는 하나의 data-flow를 가지고 있기 때문에
    복잡하지 않은 상태구조를 가지고 있다.

<br>

    3. Atom과 selector만 알고도 어느 정도 구현이 가능하기 때문에 러닝커브가 비교적 낮다.

<br>

    4. Store와 같은 외부 요인이 아닌 React 내부의 상태를 활용하고
    Context API를 통해 구현되어 있기 때문에 더 리액트에 가까운 라이브러리이다.

<br><br>

### Intersection Observer API

    - intersection Observer API는 target과 root의 교차 발생을 비동기적으로 관찰하는 web API입니다.

    - 메인 thread에 영향을 주지 않고, Callback을 실행하기에 매번 layout을 새로 그려 render tree를 새로 만들지 않기 때문에 브라우저의 성능을 향상시킬 수 있습니다.

    - 주로 무한 스크롤을 구현할 때 자주 사용되는 api입니다.

<br><br>

### useReducer , useState

    - useState는 컴포넌트 내부에서  state를 변경하는 것이 가능
    - useReducer는 컴포넌트 외부에서 state를 변경하는 것이 가능하다.

<br><br>
